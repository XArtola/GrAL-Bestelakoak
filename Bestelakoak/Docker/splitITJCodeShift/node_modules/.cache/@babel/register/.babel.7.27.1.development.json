{"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\split-specs.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformer;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n// split-specs.js\n\n// Función principal del transformador de JSCodeshift\nfunction transformer(fileInfo, api) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source); // Parsea el código fuente a un AST\n\n  // Encuentra todos los nodos de llamada a la función 'it'\n  // Nota: Buscamos la CallExpression, pero necesitamos operar sobre el\n  //       Statement que la contiene (usualmente ExpressionStatement) para removerla correctamente.\n  const itPaths = root.find(j.CallExpression, {\n    callee: {\n      name: 'it'\n    }\n  }).paths(); // Obtenemos los \"paths\" para tener más contexto\n\n  // Si no hay bloques 'it' o solo hay uno, no hacemos nada con este archivo.\n  if (itPaths.length <= 1) {\n    console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. No se requiere división.`);\n    return null; // No se generan nuevos archivos\n  }\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\n  const originalPath = fileInfo.path;\n  const dir = _path.default.dirname(originalPath);\n  const ext = _path.default.extname(originalPath); // Debería ser '.ts'\n  const baseName = _path.default.basename(originalPath, ext); // Ej: 'mi-componente.spec'\n\n  // --- Generación de un archivo por cada bloque 'it' ---\n  itPaths.forEach((targetItPath, index) => {\n    // 1. Crear una copia FRESCAdel AST original para cada archivo de salida\n    //    La forma más simple es volver a parsear la fuente original.\n    const astCopy = j(fileInfo.source);\n\n    // 2. Encontrar TODOS los 'it' DENTRO DE ESTA COPIA del AST\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\n      callee: {\n        name: 'it'\n      }\n    }).paths();\n\n    // 3. Identificar el nodo 'it' específico que queremos MANTENER en esta copia\n    //    (Basado en la posición/estructura, no es trivial comparar nodos directamente entre ASTs parseados por separado,\n    //     pero podemos asumir que el índice en la búsqueda será consistente si el código no cambia)\n    const nodeToKeep = targetItPath.node;\n\n    // 4. Eliminar TODOS los otros bloques 'it' de la copia del AST\n    allItPathsInCopy.forEach(currentItPathInCopy => {\n      // Comparamos los nodos originales para saber cuál mantener.\n      // Es una comparación superficial, pero debería funcionar si los nodos no son idénticos.\n      // Una comparación más robusta podría usar localizaciones (línea/columna) si fuera necesario.\n      if (currentItPathInCopy.node !== nodeToKeep) {\n        try {\n          // Intentamos eliminar el 'statement' padre (usualmente ExpressionStatement)\n          // que contiene la llamada a 'it'. Esto es más limpio que eliminar solo la llamada.\n          const parentStatementPath = currentItPathInCopy.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement') {\n            j(parentStatementPath).remove();\n          } else {\n            var _currentItPathInCopy$;\n            // Si 'it' no está directamente en un ExpressionStatement (raro en specs),\n            // podríamos necesitar lógica más compleja. Por ahora, intentamos quitar el 'it'.\n            j(currentItPathInCopy).remove();\n            console.warn(`Advertencia: El bloque 'it' en ${fileInfo.path} (línea ${(_currentItPathInCopy$ = currentItPathInCopy.node.loc) === null || _currentItPathInCopy$ === void 0 || (_currentItPathInCopy$ = _currentItPathInCopy$.start) === null || _currentItPathInCopy$ === void 0 ? void 0 : _currentItPathInCopy$.line}) no estaba en un ExpressionStatement directo. Se eliminó la llamada, pero podría quedar código residual.`);\n          }\n        } catch (error) {\n          console.error(`Error al intentar eliminar un bloque 'it' en ${fileInfo.path} para el archivo ${index + 1}:`, error);\n        }\n      }\n    });\n\n    // 5. Generar el código fuente desde el AST modificado (solo con un 'it')\n    //    Usamos las opciones de Recast (implícitas en jscodeshift) para intentar mantener el formato.\n    const outputSource = astCopy.toSource({\n      quote: 'single',\n      trailingComma: true\n    });\n\n    // 6. Construir el nuevo nombre de archivo\n    //    Ej: mi-componente.spec.ts -> mi-componente.spec1.ts, mi-componente.spec2.ts\n    const newFileName = `${baseName}${index + 1}${ext}`;\n    const newFilePath = _path.default.join(dir, newFileName);\n\n    // 7. Escribir el nuevo archivo\n    try {\n      _fs.default.writeFileSync(newFilePath, outputSource);\n      console.log(`   Creado: ${newFilePath}`);\n    } catch (error) {\n      console.error(`Error al escribir el archivo ${newFilePath}:`, error);\n    }\n  });\n\n  // Importante: Devolvemos 'null' para indicar a jscodeshift que NO\n  // sobrescriba el archivo original. Nosotros ya hemos creado los nuevos archivos.\n  return null;\n}\n\n// Opcional: Indica a jscodeshift que use el parser de Babel (que soporta TS)\n// Esto suele ser necesario si no pasas --parser=ts en la línea de comandos.\n// export const parser = 'ts'; // O 'tsx' si tienes JSX\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZnMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9wYXRoIiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwidHJhbnNmb3JtZXIiLCJmaWxlSW5mbyIsImFwaSIsImoiLCJqc2NvZGVzaGlmdCIsInJvb3QiLCJzb3VyY2UiLCJpdFBhdGhzIiwiZmluZCIsIkNhbGxFeHByZXNzaW9uIiwiY2FsbGVlIiwibmFtZSIsInBhdGhzIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInBhdGgiLCJvcmlnaW5hbFBhdGgiLCJkaXIiLCJkaXJuYW1lIiwiZXh0IiwiZXh0bmFtZSIsImJhc2VOYW1lIiwiYmFzZW5hbWUiLCJmb3JFYWNoIiwidGFyZ2V0SXRQYXRoIiwiaW5kZXgiLCJhc3RDb3B5IiwiYWxsSXRQYXRoc0luQ29weSIsIm5vZGVUb0tlZXAiLCJub2RlIiwiY3VycmVudEl0UGF0aEluQ29weSIsInBhcmVudFN0YXRlbWVudFBhdGgiLCJwYXJlbnRQYXRoIiwidHlwZSIsInJlbW92ZSIsIl9jdXJyZW50SXRQYXRoSW5Db3B5JCIsIndhcm4iLCJsb2MiLCJzdGFydCIsImxpbmUiLCJlcnJvciIsIm91dHB1dFNvdXJjZSIsInRvU291cmNlIiwicXVvdGUiLCJ0cmFpbGluZ0NvbW1hIiwibmV3RmlsZU5hbWUiLCJuZXdGaWxlUGF0aCIsImpvaW4iLCJmcyIsIndyaXRlRmlsZVN5bmMiXSwic291cmNlUm9vdCI6IkM6XFxVc2Vyc1xceGFiaWFcXE9uZURyaXZlXFxEb2N1bWVudG9zXFw0Lk1haWxhXFxURkctQmVzdGVsYWtvYWtcXEJlc3RlbGFrb2FrXFwzMF8wNF8yNS0xNV8wNV8yNVxcc3BsaXRJVEpDb2RlU2hpZnRcXCIsInNvdXJjZXMiOlsic3BsaXQtc3BlY3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3BsaXQtc3BlY3MuanNcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG4vLyBGdW5jacOzbiBwcmluY2lwYWwgZGVsIHRyYW5zZm9ybWFkb3IgZGUgSlNDb2Rlc2hpZnRcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtZXIoZmlsZUluZm8sIGFwaSkge1xyXG4gIGNvbnN0IGogPSBhcGkuanNjb2Rlc2hpZnQ7XHJcbiAgY29uc3Qgcm9vdCA9IGooZmlsZUluZm8uc291cmNlKTsgLy8gUGFyc2VhIGVsIGPDs2RpZ28gZnVlbnRlIGEgdW4gQVNUXHJcblxyXG4gIC8vIEVuY3VlbnRyYSB0b2RvcyBsb3Mgbm9kb3MgZGUgbGxhbWFkYSBhIGxhIGZ1bmNpw7NuICdpdCdcclxuICAvLyBOb3RhOiBCdXNjYW1vcyBsYSBDYWxsRXhwcmVzc2lvbiwgcGVybyBuZWNlc2l0YW1vcyBvcGVyYXIgc29icmUgZWxcclxuICAvLyAgICAgICBTdGF0ZW1lbnQgcXVlIGxhIGNvbnRpZW5lICh1c3VhbG1lbnRlIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHBhcmEgcmVtb3ZlcmxhIGNvcnJlY3RhbWVudGUuXHJcbiAgY29uc3QgaXRQYXRocyA9IHJvb3QuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICBjYWxsZWU6IHsgbmFtZTogJ2l0JyB9LFxyXG4gIH0pLnBhdGhzKCk7IC8vIE9idGVuZW1vcyBsb3MgXCJwYXRoc1wiIHBhcmEgdGVuZXIgbcOhcyBjb250ZXh0b1xyXG5cclxuICAvLyBTaSBubyBoYXkgYmxvcXVlcyAnaXQnIG8gc29sbyBoYXkgdW5vLCBubyBoYWNlbW9zIG5hZGEgY29uIGVzdGUgYXJjaGl2by5cclxuICBpZiAoaXRQYXRocy5sZW5ndGggPD0gMSkge1xyXG4gICAgY29uc29sZS5sb2coYC0+IEFyY2hpdm8gJHtmaWxlSW5mby5wYXRofTogJHtpdFBhdGhzLmxlbmd0aH0gYmxvcXVlKHMpICdpdCcgZW5jb250cmFkb3MuIE5vIHNlIHJlcXVpZXJlIGRpdmlzacOzbi5gKTtcclxuICAgIHJldHVybiBudWxsOyAvLyBObyBzZSBnZW5lcmFuIG51ZXZvcyBhcmNoaXZvc1xyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coYC0+IEFyY2hpdm8gJHtmaWxlSW5mby5wYXRofTogJHtpdFBhdGhzLmxlbmd0aH0gYmxvcXVlKHMpICdpdCcgZW5jb250cmFkb3MuIEdlbmVyYW5kbyBhcmNoaXZvcyBpbmRpdmlkdWFsZXMuLi5gKTtcclxuXHJcbiAgY29uc3Qgb3JpZ2luYWxQYXRoID0gZmlsZUluZm8ucGF0aDtcclxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUob3JpZ2luYWxQYXRoKTtcclxuICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUob3JpZ2luYWxQYXRoKTsgLy8gRGViZXLDrWEgc2VyICcudHMnXHJcbiAgY29uc3QgYmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKG9yaWdpbmFsUGF0aCwgZXh0KTsgLy8gRWo6ICdtaS1jb21wb25lbnRlLnNwZWMnXHJcblxyXG4gIC8vIC0tLSBHZW5lcmFjacOzbiBkZSB1biBhcmNoaXZvIHBvciBjYWRhIGJsb3F1ZSAnaXQnIC0tLVxyXG4gIGl0UGF0aHMuZm9yRWFjaCgodGFyZ2V0SXRQYXRoLCBpbmRleCkgPT4ge1xyXG4gICAgLy8gMS4gQ3JlYXIgdW5hIGNvcGlhIEZSRVNDQWRlbCBBU1Qgb3JpZ2luYWwgcGFyYSBjYWRhIGFyY2hpdm8gZGUgc2FsaWRhXHJcbiAgICAvLyAgICBMYSBmb3JtYSBtw6FzIHNpbXBsZSBlcyB2b2x2ZXIgYSBwYXJzZWFyIGxhIGZ1ZW50ZSBvcmlnaW5hbC5cclxuICAgIGNvbnN0IGFzdENvcHkgPSBqKGZpbGVJbmZvLnNvdXJjZSk7XHJcblxyXG4gICAgLy8gMi4gRW5jb250cmFyIFRPRE9TIGxvcyAnaXQnIERFTlRSTyBERSBFU1RBIENPUElBIGRlbCBBU1RcclxuICAgIGNvbnN0IGFsbEl0UGF0aHNJbkNvcHkgPSBhc3RDb3B5LmZpbmQoai5DYWxsRXhwcmVzc2lvbiwge1xyXG4gICAgICAgIGNhbGxlZTogeyBuYW1lOiAnaXQnIH0sXHJcbiAgICAgIH0pLnBhdGhzKCk7XHJcblxyXG4gICAgLy8gMy4gSWRlbnRpZmljYXIgZWwgbm9kbyAnaXQnIGVzcGVjw61maWNvIHF1ZSBxdWVyZW1vcyBNQU5URU5FUiBlbiBlc3RhIGNvcGlhXHJcbiAgICAvLyAgICAoQmFzYWRvIGVuIGxhIHBvc2ljacOzbi9lc3RydWN0dXJhLCBubyBlcyB0cml2aWFsIGNvbXBhcmFyIG5vZG9zIGRpcmVjdGFtZW50ZSBlbnRyZSBBU1RzIHBhcnNlYWRvcyBwb3Igc2VwYXJhZG8sXHJcbiAgICAvLyAgICAgcGVybyBwb2RlbW9zIGFzdW1pciBxdWUgZWwgw61uZGljZSBlbiBsYSBiw7pzcXVlZGEgc2Vyw6EgY29uc2lzdGVudGUgc2kgZWwgY8OzZGlnbyBubyBjYW1iaWEpXHJcbiAgICBjb25zdCBub2RlVG9LZWVwID0gdGFyZ2V0SXRQYXRoLm5vZGU7XHJcblxyXG4gICAgLy8gNC4gRWxpbWluYXIgVE9ET1MgbG9zIG90cm9zIGJsb3F1ZXMgJ2l0JyBkZSBsYSBjb3BpYSBkZWwgQVNUXHJcbiAgICBhbGxJdFBhdGhzSW5Db3B5LmZvckVhY2goY3VycmVudEl0UGF0aEluQ29weSA9PiB7XHJcbiAgICAgIC8vIENvbXBhcmFtb3MgbG9zIG5vZG9zIG9yaWdpbmFsZXMgcGFyYSBzYWJlciBjdcOhbCBtYW50ZW5lci5cclxuICAgICAgLy8gRXMgdW5hIGNvbXBhcmFjacOzbiBzdXBlcmZpY2lhbCwgcGVybyBkZWJlcsOtYSBmdW5jaW9uYXIgc2kgbG9zIG5vZG9zIG5vIHNvbiBpZMOpbnRpY29zLlxyXG4gICAgICAvLyBVbmEgY29tcGFyYWNpw7NuIG3DoXMgcm9idXN0YSBwb2Ryw61hIHVzYXIgbG9jYWxpemFjaW9uZXMgKGzDrW5lYS9jb2x1bW5hKSBzaSBmdWVyYSBuZWNlc2FyaW8uXHJcbiAgICAgIGlmIChjdXJyZW50SXRQYXRoSW5Db3B5Lm5vZGUgIT09IG5vZGVUb0tlZXApIHtcclxuICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgIC8vIEludGVudGFtb3MgZWxpbWluYXIgZWwgJ3N0YXRlbWVudCcgcGFkcmUgKHVzdWFsbWVudGUgRXhwcmVzc2lvblN0YXRlbWVudClcclxuICAgICAgICAgICAgIC8vIHF1ZSBjb250aWVuZSBsYSBsbGFtYWRhIGEgJ2l0Jy4gRXN0byBlcyBtw6FzIGxpbXBpbyBxdWUgZWxpbWluYXIgc29sbyBsYSBsbGFtYWRhLlxyXG4gICAgICAgICAgICAgY29uc3QgcGFyZW50U3RhdGVtZW50UGF0aCA9IGN1cnJlbnRJdFBhdGhJbkNvcHkucGFyZW50UGF0aDtcclxuICAgICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZW1lbnRQYXRoLm5vZGUudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgaihwYXJlbnRTdGF0ZW1lbnRQYXRoKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgLy8gU2kgJ2l0JyBubyBlc3TDoSBkaXJlY3RhbWVudGUgZW4gdW4gRXhwcmVzc2lvblN0YXRlbWVudCAocmFybyBlbiBzcGVjcyksXHJcbiAgICAgICAgICAgICAgICAgLy8gcG9kcsOtYW1vcyBuZWNlc2l0YXIgbMOzZ2ljYSBtw6FzIGNvbXBsZWphLiBQb3IgYWhvcmEsIGludGVudGFtb3MgcXVpdGFyIGVsICdpdCcuXHJcbiAgICAgICAgICAgICAgICAgaihjdXJyZW50SXRQYXRoSW5Db3B5KS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFkdmVydGVuY2lhOiBFbCBibG9xdWUgJ2l0JyBlbiAke2ZpbGVJbmZvLnBhdGh9IChsw61uZWEgJHtjdXJyZW50SXRQYXRoSW5Db3B5Lm5vZGUubG9jPy5zdGFydD8ubGluZX0pIG5vIGVzdGFiYSBlbiB1biBFeHByZXNzaW9uU3RhdGVtZW50IGRpcmVjdG8uIFNlIGVsaW1pbsOzIGxhIGxsYW1hZGEsIHBlcm8gcG9kcsOtYSBxdWVkYXIgY8OzZGlnbyByZXNpZHVhbC5gKTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbCBpbnRlbnRhciBlbGltaW5hciB1biBibG9xdWUgJ2l0JyBlbiAke2ZpbGVJbmZvLnBhdGh9IHBhcmEgZWwgYXJjaGl2byAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDUuIEdlbmVyYXIgZWwgY8OzZGlnbyBmdWVudGUgZGVzZGUgZWwgQVNUIG1vZGlmaWNhZG8gKHNvbG8gY29uIHVuICdpdCcpXHJcbiAgICAvLyAgICBVc2Ftb3MgbGFzIG9wY2lvbmVzIGRlIFJlY2FzdCAoaW1wbMOtY2l0YXMgZW4ganNjb2Rlc2hpZnQpIHBhcmEgaW50ZW50YXIgbWFudGVuZXIgZWwgZm9ybWF0by5cclxuICAgIGNvbnN0IG91dHB1dFNvdXJjZSA9IGFzdENvcHkudG9Tb3VyY2UoeyBxdW90ZTogJ3NpbmdsZScsIHRyYWlsaW5nQ29tbWE6IHRydWUgfSk7XHJcblxyXG4gICAgLy8gNi4gQ29uc3RydWlyIGVsIG51ZXZvIG5vbWJyZSBkZSBhcmNoaXZvXHJcbiAgICAvLyAgICBFajogbWktY29tcG9uZW50ZS5zcGVjLnRzIC0+IG1pLWNvbXBvbmVudGUuc3BlYzEudHMsIG1pLWNvbXBvbmVudGUuc3BlYzIudHNcclxuICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gYCR7YmFzZU5hbWV9JHtpbmRleCArIDF9JHtleHR9YDtcclxuICAgIGNvbnN0IG5ld0ZpbGVQYXRoID0gcGF0aC5qb2luKGRpciwgbmV3RmlsZU5hbWUpO1xyXG5cclxuICAgIC8vIDcuIEVzY3JpYmlyIGVsIG51ZXZvIGFyY2hpdm9cclxuICAgIHRyeSB7XHJcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMobmV3RmlsZVBhdGgsIG91dHB1dFNvdXJjZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICBDcmVhZG86ICR7bmV3RmlsZVBhdGh9YCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbCBlc2NyaWJpciBlbCBhcmNoaXZvICR7bmV3RmlsZVBhdGh9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gSW1wb3J0YW50ZTogRGV2b2x2ZW1vcyAnbnVsbCcgcGFyYSBpbmRpY2FyIGEganNjb2Rlc2hpZnQgcXVlIE5PXHJcbiAgLy8gc29icmVzY3JpYmEgZWwgYXJjaGl2byBvcmlnaW5hbC4gTm9zb3Ryb3MgeWEgaGVtb3MgY3JlYWRvIGxvcyBudWV2b3MgYXJjaGl2b3MuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8vIE9wY2lvbmFsOiBJbmRpY2EgYSBqc2NvZGVzaGlmdCBxdWUgdXNlIGVsIHBhcnNlciBkZSBCYWJlbCAocXVlIHNvcG9ydGEgVFMpXHJcbi8vIEVzdG8gc3VlbGUgc2VyIG5lY2VzYXJpbyBzaSBubyBwYXNhcyAtLXBhcnNlcj10cyBlbiBsYSBsw61uZWEgZGUgY29tYW5kb3MuXHJcbi8vIGV4cG9ydCBjb25zdCBwYXJzZXIgPSAndHMnOyAvLyBPICd0c3gnIHNpIHRpZW5lcyBKU1giXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLElBQUFBLEdBQUEsR0FBQUMsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBLElBQUFDLEtBQUEsR0FBQUYsc0JBQUEsQ0FBQUMsT0FBQTtBQUF3QixTQUFBRCx1QkFBQUcsQ0FBQSxXQUFBQSxDQUFBLElBQUFBLENBQUEsQ0FBQUMsVUFBQSxHQUFBRCxDQUFBLEtBQUFFLE9BQUEsRUFBQUYsQ0FBQTtBQUZ4Qjs7QUFJQTtBQUNlLFNBQVNHLFdBQVdBLENBQUNDLFFBQVEsRUFBRUMsR0FBRyxFQUFFO0VBQ2pELE1BQU1DLENBQUMsR0FBR0QsR0FBRyxDQUFDRSxXQUFXO0VBQ3pCLE1BQU1DLElBQUksR0FBR0YsQ0FBQyxDQUFDRixRQUFRLENBQUNLLE1BQU0sQ0FBQyxDQUFDLENBQUM7O0VBRWpDO0VBQ0E7RUFDQTtFQUNB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","map":{"version":3,"names":["_fs","_interopRequireDefault","require","_path","e","__esModule","default","transformer","fileInfo","api","j","jscodeshift","root","source","itPaths","find","CallExpression","callee","name","paths","length","console","log","path","originalPath","dir","dirname","ext","extname","baseName","basename","forEach","targetItPath","index","astCopy","allItPathsInCopy","nodeToKeep","node","currentItPathInCopy","parentStatementPath","parentPath","type","remove","_currentItPathInCopy$","warn","loc","start","line","error","outputSource","toSource","quote","trailingComma","newFileName","newFilePath","join","fs","writeFileSync"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\30_04_25-15_05_25\\splitITJCodeShift\\","sources":["split-specs.js"],"sourcesContent":["// split-specs.js\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\n// Función principal del transformador de JSCodeshift\r\nexport default function transformer(fileInfo, api) {\r\n  const j = api.jscodeshift;\r\n  const root = j(fileInfo.source); // Parsea el código fuente a un AST\r\n\r\n  // Encuentra todos los nodos de llamada a la función 'it'\r\n  // Nota: Buscamos la CallExpression, pero necesitamos operar sobre el\r\n  //       Statement que la contiene (usualmente ExpressionStatement) para removerla correctamente.\r\n  const itPaths = root.find(j.CallExpression, {\r\n    callee: { name: 'it' },\r\n  }).paths(); // Obtenemos los \"paths\" para tener más contexto\r\n\r\n  // Si no hay bloques 'it' o solo hay uno, no hacemos nada con este archivo.\r\n  if (itPaths.length <= 1) {\r\n    console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. No se requiere división.`);\r\n    return null; // No se generan nuevos archivos\r\n  }\r\n\r\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\r\n\r\n  const originalPath = fileInfo.path;\r\n  const dir = path.dirname(originalPath);\r\n  const ext = path.extname(originalPath); // Debería ser '.ts'\r\n  const baseName = path.basename(originalPath, ext); // Ej: 'mi-componente.spec'\r\n\r\n  // --- Generación de un archivo por cada bloque 'it' ---\r\n  itPaths.forEach((targetItPath, index) => {\r\n    // 1. Crear una copia FRESCAdel AST original para cada archivo de salida\r\n    //    La forma más simple es volver a parsear la fuente original.\r\n    const astCopy = j(fileInfo.source);\r\n\r\n    // 2. Encontrar TODOS los 'it' DENTRO DE ESTA COPIA del AST\r\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\r\n        callee: { name: 'it' },\r\n      }).paths();\r\n\r\n    // 3. Identificar el nodo 'it' específico que queremos MANTENER en esta copia\r\n    //    (Basado en la posición/estructura, no es trivial comparar nodos directamente entre ASTs parseados por separado,\r\n    //     pero podemos asumir que el índice en la búsqueda será consistente si el código no cambia)\r\n    const nodeToKeep = targetItPath.node;\r\n\r\n    // 4. Eliminar TODOS los otros bloques 'it' de la copia del AST\r\n    allItPathsInCopy.forEach(currentItPathInCopy => {\r\n      // Comparamos los nodos originales para saber cuál mantener.\r\n      // Es una comparación superficial, pero debería funcionar si los nodos no son idénticos.\r\n      // Una comparación más robusta podría usar localizaciones (línea/columna) si fuera necesario.\r\n      if (currentItPathInCopy.node !== nodeToKeep) {\r\n         try {\r\n             // Intentamos eliminar el 'statement' padre (usualmente ExpressionStatement)\r\n             // que contiene la llamada a 'it'. Esto es más limpio que eliminar solo la llamada.\r\n             const parentStatementPath = currentItPathInCopy.parentPath;\r\n             if (parentStatementPath.node.type === 'ExpressionStatement') {\r\n                 j(parentStatementPath).remove();\r\n             } else {\r\n                 // Si 'it' no está directamente en un ExpressionStatement (raro en specs),\r\n                 // podríamos necesitar lógica más compleja. Por ahora, intentamos quitar el 'it'.\r\n                 j(currentItPathInCopy).remove();\r\n                 console.warn(`Advertencia: El bloque 'it' en ${fileInfo.path} (línea ${currentItPathInCopy.node.loc?.start?.line}) no estaba en un ExpressionStatement directo. Se eliminó la llamada, pero podría quedar código residual.`);\r\n             }\r\n         } catch (error) {\r\n              console.error(`Error al intentar eliminar un bloque 'it' en ${fileInfo.path} para el archivo ${index + 1}:`, error);\r\n         }\r\n      }\r\n    });\r\n\r\n    // 5. Generar el código fuente desde el AST modificado (solo con un 'it')\r\n    //    Usamos las opciones de Recast (implícitas en jscodeshift) para intentar mantener el formato.\r\n    const outputSource = astCopy.toSource({ quote: 'single', trailingComma: true });\r\n\r\n    // 6. Construir el nuevo nombre de archivo\r\n    //    Ej: mi-componente.spec.ts -> mi-componente.spec1.ts, mi-componente.spec2.ts\r\n    const newFileName = `${baseName}${index + 1}${ext}`;\r\n    const newFilePath = path.join(dir, newFileName);\r\n\r\n    // 7. Escribir el nuevo archivo\r\n    try {\r\n      fs.writeFileSync(newFilePath, outputSource);\r\n      console.log(`   Creado: ${newFilePath}`);\r\n    } catch (error) {\r\n      console.error(`Error al escribir el archivo ${newFilePath}:`, error);\r\n    }\r\n  });\r\n\r\n  // Importante: Devolvemos 'null' para indicar a jscodeshift que NO\r\n  // sobrescriba el archivo original. Nosotros ya hemos creado los nuevos archivos.\r\n  return null;\r\n}\r\n\r\n// Opcional: Indica a jscodeshift que use el parser de Babel (que soporta TS)\r\n// Esto suele ser necesario si no pasas --parser=ts en la línea de comandos.\r\n// export const parser = 'ts'; // O 'tsx' si tienes JSX"],"mappings":"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","ignoreList":[]}},"mtime":1746461525405},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\node_modules\\\\jscodeshift\\\\parser\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\node_modules\\\\jscodeshift\\\\parser\\\\ts.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst babylon = require('@babel/parser');\nconst options = require('./tsOptions');\n\n/**\n * Doesn't accept custom options because babylon should be used directly in\n * that case.\n */\nmodule.exports = function () {\n  return {\n    parse(code) {\n      return babylon.parse(code, options);\n    }\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJiYWJ5bG9uIiwicmVxdWlyZSIsIm9wdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2UiLCJjb2RlIl0sInNvdXJjZVJvb3QiOiJDOlxcVXNlcnNcXHhhYmlhXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcNC5NYWlsYVxcVEZHLUJlc3RlbGFrb2FrXFxCZXN0ZWxha29ha1xcMzBfMDRfMjUtMTVfMDVfMjVcXHNwbGl0SVRKQ29kZVNoaWZ0XFxub2RlX21vZHVsZXNcXGpzY29kZXNoaWZ0XFxwYXJzZXJcXCIsInNvdXJjZXMiOlsidHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgYmFieWxvbiA9IHJlcXVpcmUoJ0BiYWJlbC9wYXJzZXInKTtcbmNvbnN0IG9wdGlvbnMgPSByZXF1aXJlKCcuL3RzT3B0aW9ucycpO1xuXG4vKipcbiAqIERvZXNuJ3QgYWNjZXB0IGN1c3RvbSBvcHRpb25zIGJlY2F1c2UgYmFieWxvbiBzaG91bGQgYmUgdXNlZCBkaXJlY3RseSBpblxuICogdGhhdCBjYXNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHBhcnNlKGNvZGUpIHtcbiAgICAgIHJldHVybiBiYWJ5bG9uLnBhcnNlKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gIH07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWixNQUFNQSxPQUFPLEdBQUdDLE9BQU8sQ0FBQyxlQUFlLENBQUM7QUFDeEMsTUFBTUMsT0FBTyxHQUFHRCxPQUFPLENBQUMsYUFBYSxDQUFDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBRSxNQUFNLENBQUNDLE9BQU8sR0FBRyxZQUFXO0VBQzFCLE9BQU87SUFDTEMsS0FBS0EsQ0FBQ0MsSUFBSSxFQUFFO01BQ1YsT0FBT04sT0FBTyxDQUFDSyxLQUFLLENBQUNDLElBQUksRUFBRUosT0FBTyxDQUFDO0lBQ3JDO0VBQ0YsQ0FBQztBQUNILENBQUMiLCJpZ25vcmVMaXN0IjpbXX0=","map":{"version":3,"names":["babylon","require","options","module","exports","parse","code"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\30_04_25-15_05_25\\splitITJCodeShift\\node_modules\\jscodeshift\\parser\\","sources":["ts.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst babylon = require('@babel/parser');\nconst options = require('./tsOptions');\n\n/**\n * Doesn't accept custom options because babylon should be used directly in\n * that case.\n */\nmodule.exports = function() {\n  return {\n    parse(code) {\n      return babylon.parse(code, options);\n    },\n  };\n};\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,eAAe,CAAC;AACxC,MAAMC,OAAO,GAAGD,OAAO,CAAC,aAAa,CAAC;;AAEtC;AACA;AACA;AACA;AACAE,MAAM,CAACC,OAAO,GAAG,YAAW;EAC1B,OAAO;IACLC,KAAKA,CAACC,IAAI,EAAE;MACV,OAAON,OAAO,CAACK,KAAK,CAACC,IAAI,EAAEJ,OAAO,CAAC;IACrC;EACF,CAAC;AACH,CAAC","ignoreList":[]}},"mtime":1746461488457},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\node_modules\\\\jscodeshift\\\\parser\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\node_modules\\\\jscodeshift\\\\parser\\\\tsOptions.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Options shared by the TypeScript and TSX parsers.\n */\nmodule.exports = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: ['asyncGenerators', 'decoratorAutoAccessors', 'bigInt', 'classPrivateMethods', 'classPrivateProperties', 'classProperties', 'decorators-legacy', 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportExtensions', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importAttributes', 'importMeta', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', ['pipelineOperator', {\n    proposal: 'minimal'\n  }], 'throwExpressions', 'typescript']\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwic291cmNlVHlwZSIsImFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSIsImFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uIiwic3RhcnRMaW5lIiwidG9rZW5zIiwicGx1Z2lucyIsInByb3Bvc2FsIl0sInNvdXJjZVJvb3QiOiJDOlxcVXNlcnNcXHhhYmlhXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcNC5NYWlsYVxcVEZHLUJlc3RlbGFrb2FrXFxCZXN0ZWxha29ha1xcMzBfMDRfMjUtMTVfMDVfMjVcXHNwbGl0SVRKQ29kZVNoaWZ0XFxub2RlX21vZHVsZXNcXGpzY29kZXNoaWZ0XFxwYXJzZXJcXCIsInNvdXJjZXMiOlsidHNPcHRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogT3B0aW9ucyBzaGFyZWQgYnkgdGhlIFR5cGVTY3JpcHQgYW5kIFRTWCBwYXJzZXJzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc291cmNlVHlwZTogJ21vZHVsZScsXG4gIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogdHJ1ZSxcbiAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IHRydWUsXG4gIHN0YXJ0TGluZTogMSxcbiAgdG9rZW5zOiB0cnVlLFxuICBwbHVnaW5zOiBbXG4gICAgJ2FzeW5jR2VuZXJhdG9ycycsXG4gICAgJ2RlY29yYXRvckF1dG9BY2Nlc3NvcnMnLFxuICAgICdiaWdJbnQnLFxuICAgICdjbGFzc1ByaXZhdGVNZXRob2RzJyxcbiAgICAnY2xhc3NQcml2YXRlUHJvcGVydGllcycsXG4gICAgJ2NsYXNzUHJvcGVydGllcycsXG4gICAgJ2RlY29yYXRvcnMtbGVnYWN5JyxcbiAgICAnZG9FeHByZXNzaW9ucycsXG4gICAgJ2R5bmFtaWNJbXBvcnQnLFxuICAgICdleHBvcnREZWZhdWx0RnJvbScsXG4gICAgJ2V4cG9ydEV4dGVuc2lvbnMnLFxuICAgICdleHBvcnROYW1lc3BhY2VGcm9tJyxcbiAgICAnZnVuY3Rpb25CaW5kJyxcbiAgICAnZnVuY3Rpb25TZW50JyxcbiAgICAnaW1wb3J0QXR0cmlidXRlcycsXG4gICAgJ2ltcG9ydE1ldGEnLFxuICAgICdudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yJyxcbiAgICAnbnVtZXJpY1NlcGFyYXRvcicsXG4gICAgJ29iamVjdFJlc3RTcHJlYWQnLFxuICAgICdvcHRpb25hbENhdGNoQmluZGluZycsXG4gICAgJ29wdGlvbmFsQ2hhaW5pbmcnLFxuICAgIFsncGlwZWxpbmVPcGVyYXRvcicsIHsgcHJvcG9zYWw6ICdtaW5pbWFsJyB9XSxcbiAgICAndGhyb3dFeHByZXNzaW9ucycsXG4gICAgJ3R5cGVzY3JpcHQnXG4gIF0sXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQUEsTUFBTSxDQUFDQyxPQUFPLEdBQUc7RUFDZkMsVUFBVSxFQUFFLFFBQVE7RUFDcEJDLDJCQUEyQixFQUFFLElBQUk7RUFDakNDLDBCQUEwQixFQUFFLElBQUk7RUFDaENDLFNBQVMsRUFBRSxDQUFDO0VBQ1pDLE1BQU0sRUFBRSxJQUFJO0VBQ1pDLE9BQU8sRUFBRSxDQUNQLGlCQUFpQixFQUNqQix3QkFBd0IsRUFDeEIsUUFBUSxFQUNSLHFCQUFxQixFQUNyQix3QkFBd0IsRUFDeEIsaUJBQWlCLEVBQ2pCLG1CQUFtQixFQUNuQixlQUFlLEVBQ2YsZUFBZSxFQUNmLG1CQUFtQixFQUNuQixrQkFBa0IsRUFDbEIscUJBQXFCLEVBQ3JCLGNBQWMsRUFDZCxjQUFjLEVBQ2Qsa0JBQWtCLEVBQ2xCLFlBQVksRUFDWiwyQkFBMkIsRUFDM0Isa0JBQWtCLEVBQ2xCLGtCQUFrQixFQUNsQixzQkFBc0IsRUFDdEIsa0JBQWtCLEVBQ2xCLENBQUMsa0JBQWtCLEVBQUU7SUFBRUMsUUFBUSxFQUFFO0VBQVUsQ0FBQyxDQUFDLEVBQzdDLGtCQUFrQixFQUNsQixZQUFZO0FBRWhCLENBQUMiLCJpZ25vcmVMaXN0IjpbXX0=","map":{"version":3,"names":["module","exports","sourceType","allowImportExportEverywhere","allowReturnOutsideFunction","startLine","tokens","plugins","proposal"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\30_04_25-15_05_25\\splitITJCodeShift\\node_modules\\jscodeshift\\parser\\","sources":["tsOptions.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Options shared by the TypeScript and TSX parsers.\n */\nmodule.exports = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: [\n    'asyncGenerators',\n    'decoratorAutoAccessors',\n    'bigInt',\n    'classPrivateMethods',\n    'classPrivateProperties',\n    'classProperties',\n    'decorators-legacy',\n    'doExpressions',\n    'dynamicImport',\n    'exportDefaultFrom',\n    'exportExtensions',\n    'exportNamespaceFrom',\n    'functionBind',\n    'functionSent',\n    'importAttributes',\n    'importMeta',\n    'nullishCoalescingOperator',\n    'numericSeparator',\n    'objectRestSpread',\n    'optionalCatchBinding',\n    'optionalChaining',\n    ['pipelineOperator', { proposal: 'minimal' }],\n    'throwExpressions',\n    'typescript'\n  ],\n};\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAG;EACfC,UAAU,EAAE,QAAQ;EACpBC,2BAA2B,EAAE,IAAI;EACjCC,0BAA0B,EAAE,IAAI;EAChCC,SAAS,EAAE,CAAC;EACZC,MAAM,EAAE,IAAI;EACZC,OAAO,EAAE,CACP,iBAAiB,EACjB,wBAAwB,EACxB,QAAQ,EACR,qBAAqB,EACrB,wBAAwB,EACxB,iBAAiB,EACjB,mBAAmB,EACnB,eAAe,EACf,eAAe,EACf,mBAAmB,EACnB,kBAAkB,EAClB,qBAAqB,EACrB,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,YAAY,EACZ,2BAA2B,EAC3B,kBAAkB,EAClB,kBAAkB,EAClB,sBAAsB,EACtB,kBAAkB,EAClB,CAAC,kBAAkB,EAAE;IAAEC,QAAQ,EAAE;EAAU,CAAC,CAAC,EAC7C,kBAAkB,EAClB,YAAY;AAEhB,CAAC","ignoreList":[]}},"mtime":1746461488461},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\split-specs2.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformer;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n// split-specs.js\n\n// --- Helper Function ---\n// Compara si dos objetos de ubicación AST son iguales\nconst locationsAreEqual = (locA, locB) => {\n  if (!locA || !locB) return false; // Safety check si falta info de ubicación\n  try {\n    return locA.start.line === locB.start.line && locA.start.column === locB.start.column && locA.end.line === locB.end.line && locA.end.column === locB.end.column;\n  } catch (e) {\n    // En caso de error accediendo a las propiedades (muy raro)\n    console.error(\"Error comparando localizaciones:\", e);\n    return false;\n  }\n};\n// --- Fin Helper ---\n\n// Función principal del transformador de JSCodeshift\nfunction transformer(fileInfo, api) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source); // Parsea el código fuente original\n\n  // Encuentra todos los nodos de llamada a la función 'it' en el AST original\n  const itPaths = root.find(j.CallExpression, {\n    callee: {\n      name: 'it'\n    }\n  }).paths();\n\n  // Si no hay bloques 'it' o solo hay uno, no hacemos nada con este archivo.\n  if (itPaths.length <= 1) {\n    // console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it'. No se requiere división.`);\n    // Devolver null/undefined hace que jscodeshift lo cuente como 'skipped'\n    return undefined;\n  }\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\n  const originalPath = fileInfo.path;\n  const dir = _path.default.dirname(originalPath);\n  const ext = _path.default.extname(originalPath);\n  const baseName = _path.default.basename(originalPath, ext);\n\n  // --- Generación de un archivo por cada bloque 'it' ---\n  itPaths.forEach((targetItPath, index) => {\n    // 1. Crear una copia FRESCA del AST original para CADA archivo de salida\n    const astCopy = j(fileInfo.source);\n\n    // 2. Encontrar TODOS los 'it' DENTRO DE ESTA COPIA del AST\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\n      callee: {\n        name: 'it'\n      }\n    }).paths();\n\n    // 3. Obtener la ubicación del nodo 'it' que queremos MANTENER (del AST original)\n    const targetLoc = targetItPath.node.loc;\n\n    // Seguridad: Si por alguna razón el nodo original no tiene 'loc', no podemos continuar esta iteración.\n    if (!targetLoc) {\n      console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\n      return; // Saltar a la siguiente iteración del forEach\n    }\n\n    // 4. Eliminar TODOS los otros bloques 'it' cuya ubicación NO COINCIDA con targetLoc\n    allItPathsInCopy.forEach(currentItPathInCopy => {\n      const currentLoc = currentItPathInCopy.node.loc;\n\n      // Si las ubicaciones NO coinciden, ESTE es un nodo para eliminar\n      if (!locationsAreEqual(currentLoc, targetLoc)) {\n        try {\n          var _parentStatementPath$;\n          // Intentar eliminar el 'statement' padre (usualmente ExpressionStatement)\n          const parentStatementPath = currentItPathInCopy.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement' && (_parentStatementPath$ = parentStatementPath.parentPath) !== null && _parentStatementPath$ !== void 0 && (_parentStatementPath$ = _parentStatementPath$.node) !== null && _parentStatementPath$ !== void 0 && _parentStatementPath$.type) {\n            // Comprobación extra: Asegurarse de que el abuelo existe (para evitar errores en el borde del AST)\n            j(parentStatementPath).remove();\n          } else {\n            var _currentLoc$start;\n            j(currentItPathInCopy).remove(); // Fallback menos ideal\n            console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start = currentLoc.start) === null || _currentLoc$start === void 0 ? void 0 : _currentLoc$start.line}). Revise el archivo ${index + 1}.`);\n          }\n        } catch (error) {\n          var _currentLoc$start2;\n          console.error(`Error eliminando bloque 'it' (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start2 = currentLoc.start) === null || _currentLoc$start2 === void 0 ? void 0 : _currentLoc$start2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\n        }\n      }\n      // Else: Las ubicaciones coinciden -> Este es el nodo a conservar, NO HACER NADA.\n    });\n\n    // 5. Generar código fuente desde el AST modificado\n    const outputSource = astCopy.toSource({\n      quote: 'single',\n      trailingComma: true\n    });\n\n    // 6. Construir nuevo nombre de archivo\n    const newFileName = `${baseName}${index + 1}${ext}`;\n    const newFilePath = _path.default.join(dir, newFileName);\n\n    // 7. Escribir el nuevo archivo\n    try {\n      _fs.default.writeFileSync(newFilePath, outputSource);\n      console.log(`   Creado: ${newFilePath}`);\n    } catch (error) {\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\n    }\n  });\n\n  // Importante: Devolver undefined/null para no modificar el original\n  return undefined;\n}\n\n// Opcional pero recomendado si no usas --parser=ts en la línea de comandos\n// export const parser = 'ts';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZnMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9wYXRoIiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwibG9jYXRpb25zQXJlRXF1YWwiLCJsb2NBIiwibG9jQiIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsImVuZCIsImNvbnNvbGUiLCJlcnJvciIsInRyYW5zZm9ybWVyIiwiZmlsZUluZm8iLCJhcGkiLCJqIiwianNjb2Rlc2hpZnQiLCJyb290Iiwic291cmNlIiwiaXRQYXRocyIsImZpbmQiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsIm5hbWUiLCJwYXRocyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImxvZyIsInBhdGgiLCJvcmlnaW5hbFBhdGgiLCJkaXIiLCJkaXJuYW1lIiwiZXh0IiwiZXh0bmFtZSIsImJhc2VOYW1lIiwiYmFzZW5hbWUiLCJmb3JFYWNoIiwidGFyZ2V0SXRQYXRoIiwiaW5kZXgiLCJhc3RDb3B5IiwiYWxsSXRQYXRoc0luQ29weSIsInRhcmdldExvYyIsIm5vZGUiLCJsb2MiLCJjdXJyZW50SXRQYXRoSW5Db3B5IiwiY3VycmVudExvYyIsIl9wYXJlbnRTdGF0ZW1lbnRQYXRoJCIsInBhcmVudFN0YXRlbWVudFBhdGgiLCJwYXJlbnRQYXRoIiwidHlwZSIsInJlbW92ZSIsIl9jdXJyZW50TG9jJHN0YXJ0Iiwid2FybiIsIl9jdXJyZW50TG9jJHN0YXJ0MiIsIm91dHB1dFNvdXJjZSIsInRvU291cmNlIiwicXVvdGUiLCJ0cmFpbGluZ0NvbW1hIiwibmV3RmlsZU5hbWUiLCJuZXdGaWxlUGF0aCIsImpvaW4iLCJmcyIsIndyaXRlRmlsZVN5bmMiXSwic291cmNlUm9vdCI6IkM6XFxVc2Vyc1xceGFiaWFcXE9uZURyaXZlXFxEb2N1bWVudG9zXFw0Lk1haWxhXFxURkctQmVzdGVsYWtvYWtcXEJlc3RlbGFrb2FrXFwzMF8wNF8yNS0xNV8wNV8yNVxcc3BsaXRJVEpDb2RlU2hpZnRcXCIsInNvdXJjZXMiOlsic3BsaXQtc3BlY3MyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNwbGl0LXNwZWNzLmpzXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuLy8gLS0tIEhlbHBlciBGdW5jdGlvbiAtLS1cclxuLy8gQ29tcGFyYSBzaSBkb3Mgb2JqZXRvcyBkZSB1YmljYWNpw7NuIEFTVCBzb24gaWd1YWxlc1xyXG5jb25zdCBsb2NhdGlvbnNBcmVFcXVhbCA9IChsb2NBLCBsb2NCKSA9PiB7XHJcbiAgICBpZiAoIWxvY0EgfHwgIWxvY0IpIHJldHVybiBmYWxzZTsgLy8gU2FmZXR5IGNoZWNrIHNpIGZhbHRhIGluZm8gZGUgdWJpY2FjacOzblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBsb2NBLnN0YXJ0LmxpbmUgPT09IGxvY0Iuc3RhcnQubGluZSAmJlxyXG4gICAgICAgICAgICBsb2NBLnN0YXJ0LmNvbHVtbiA9PT0gbG9jQi5zdGFydC5jb2x1bW4gJiZcclxuICAgICAgICAgICAgbG9jQS5lbmQubGluZSA9PT0gbG9jQi5lbmQubGluZSAmJlxyXG4gICAgICAgICAgICBsb2NBLmVuZC5jb2x1bW4gPT09IGxvY0IuZW5kLmNvbHVtblxyXG4gICAgICAgICk7XHJcbiAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAvLyBFbiBjYXNvIGRlIGVycm9yIGFjY2VkaWVuZG8gYSBsYXMgcHJvcGllZGFkZXMgKG11eSByYXJvKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb21wYXJhbmRvIGxvY2FsaXphY2lvbmVzOlwiLCBlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbi8vIC0tLSBGaW4gSGVscGVyIC0tLVxyXG5cclxuXHJcbi8vIEZ1bmNpw7NuIHByaW5jaXBhbCBkZWwgdHJhbnNmb3JtYWRvciBkZSBKU0NvZGVzaGlmdFxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1lcihmaWxlSW5mbywgYXBpKSB7XHJcbiAgY29uc3QgaiA9IGFwaS5qc2NvZGVzaGlmdDtcclxuICBjb25zdCByb290ID0gaihmaWxlSW5mby5zb3VyY2UpOyAvLyBQYXJzZWEgZWwgY8OzZGlnbyBmdWVudGUgb3JpZ2luYWxcclxuXHJcbiAgLy8gRW5jdWVudHJhIHRvZG9zIGxvcyBub2RvcyBkZSBsbGFtYWRhIGEgbGEgZnVuY2nDs24gJ2l0JyBlbiBlbCBBU1Qgb3JpZ2luYWxcclxuICBjb25zdCBpdFBhdGhzID0gcm9vdC5maW5kKGouQ2FsbEV4cHJlc3Npb24sIHtcclxuICAgIGNhbGxlZTogeyBuYW1lOiAnaXQnIH0sXHJcbiAgfSkucGF0aHMoKTtcclxuXHJcbiAgLy8gU2kgbm8gaGF5IGJsb3F1ZXMgJ2l0JyBvIHNvbG8gaGF5IHVubywgbm8gaGFjZW1vcyBuYWRhIGNvbiBlc3RlIGFyY2hpdm8uXHJcbiAgaWYgKGl0UGF0aHMubGVuZ3RoIDw9IDEpIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKGAtPiBBcmNoaXZvICR7ZmlsZUluZm8ucGF0aH06ICR7aXRQYXRocy5sZW5ndGh9IGJsb3F1ZShzKSAnaXQnLiBObyBzZSByZXF1aWVyZSBkaXZpc2nDs24uYCk7XHJcbiAgICAvLyBEZXZvbHZlciBudWxsL3VuZGVmaW5lZCBoYWNlIHF1ZSBqc2NvZGVzaGlmdCBsbyBjdWVudGUgY29tbyAnc2tpcHBlZCdcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhgLT4gQXJjaGl2byAke2ZpbGVJbmZvLnBhdGh9OiAke2l0UGF0aHMubGVuZ3RofSBibG9xdWUocykgJ2l0JyBlbmNvbnRyYWRvcy4gR2VuZXJhbmRvIGFyY2hpdm9zIGluZGl2aWR1YWxlcy4uLmApO1xyXG5cclxuICBjb25zdCBvcmlnaW5hbFBhdGggPSBmaWxlSW5mby5wYXRoO1xyXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShvcmlnaW5hbFBhdGgpO1xyXG4gIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZShvcmlnaW5hbFBhdGgpO1xyXG4gIGNvbnN0IGJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShvcmlnaW5hbFBhdGgsIGV4dCk7XHJcblxyXG4gIC8vIC0tLSBHZW5lcmFjacOzbiBkZSB1biBhcmNoaXZvIHBvciBjYWRhIGJsb3F1ZSAnaXQnIC0tLVxyXG4gIGl0UGF0aHMuZm9yRWFjaCgodGFyZ2V0SXRQYXRoLCBpbmRleCkgPT4ge1xyXG4gICAgLy8gMS4gQ3JlYXIgdW5hIGNvcGlhIEZSRVNDQSBkZWwgQVNUIG9yaWdpbmFsIHBhcmEgQ0FEQSBhcmNoaXZvIGRlIHNhbGlkYVxyXG4gICAgY29uc3QgYXN0Q29weSA9IGooZmlsZUluZm8uc291cmNlKTtcclxuXHJcbiAgICAvLyAyLiBFbmNvbnRyYXIgVE9ET1MgbG9zICdpdCcgREVOVFJPIERFIEVTVEEgQ09QSUEgZGVsIEFTVFxyXG4gICAgY29uc3QgYWxsSXRQYXRoc0luQ29weSA9IGFzdENvcHkuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICAgICAgY2FsbGVlOiB7IG5hbWU6ICdpdCcgfSxcclxuICAgICAgfSkucGF0aHMoKTtcclxuXHJcbiAgICAvLyAzLiBPYnRlbmVyIGxhIHViaWNhY2nDs24gZGVsIG5vZG8gJ2l0JyBxdWUgcXVlcmVtb3MgTUFOVEVORVIgKGRlbCBBU1Qgb3JpZ2luYWwpXHJcbiAgICBjb25zdCB0YXJnZXRMb2MgPSB0YXJnZXRJdFBhdGgubm9kZS5sb2M7XHJcblxyXG4gICAgLy8gU2VndXJpZGFkOiBTaSBwb3IgYWxndW5hIHJhesOzbiBlbCBub2RvIG9yaWdpbmFsIG5vIHRpZW5lICdsb2MnLCBubyBwb2RlbW9zIGNvbnRpbnVhciBlc3RhIGl0ZXJhY2nDs24uXHJcbiAgICBpZiAoIXRhcmdldExvYykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIENyw610aWNvOiBGYWx0YSBpbmZvcm1hY2nDs24gZGUgdWJpY2FjacOzbiBwYXJhIGVsIGJsb3F1ZSAnaXQnICjDrW5kaWNlICR7aW5kZXh9KSBlbiAke2ZpbGVJbmZvLnBhdGh9LiBObyBzZSBwdWVkZSBnZW5lcmFyIGFyY2hpdm8gJHtpbmRleCArIDF9LmApO1xyXG4gICAgICAgIHJldHVybjsgLy8gU2FsdGFyIGEgbGEgc2lndWllbnRlIGl0ZXJhY2nDs24gZGVsIGZvckVhY2hcclxuICAgIH1cclxuXHJcbiAgICAvLyA0LiBFbGltaW5hciBUT0RPUyBsb3Mgb3Ryb3MgYmxvcXVlcyAnaXQnIGN1eWEgdWJpY2FjacOzbiBOTyBDT0lOQ0lEQSBjb24gdGFyZ2V0TG9jXHJcbiAgICBhbGxJdFBhdGhzSW5Db3B5LmZvckVhY2goY3VycmVudEl0UGF0aEluQ29weSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudExvYyA9IGN1cnJlbnRJdFBhdGhJbkNvcHkubm9kZS5sb2M7XHJcblxyXG4gICAgICAgIC8vIFNpIGxhcyB1YmljYWNpb25lcyBOTyBjb2luY2lkZW4sIEVTVEUgZXMgdW4gbm9kbyBwYXJhIGVsaW1pbmFyXHJcbiAgICAgICAgaWYgKCFsb2NhdGlvbnNBcmVFcXVhbChjdXJyZW50TG9jLCB0YXJnZXRMb2MpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbnRlbnRhciBlbGltaW5hciBlbCAnc3RhdGVtZW50JyBwYWRyZSAodXN1YWxtZW50ZSBFeHByZXNzaW9uU3RhdGVtZW50KVxyXG4gICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0YXRlbWVudFBhdGggPSBjdXJyZW50SXRQYXRoSW5Db3B5LnBhcmVudFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlbWVudFBhdGgubm9kZS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgJiYgcGFyZW50U3RhdGVtZW50UGF0aC5wYXJlbnRQYXRoPy5ub2RlPy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vIENvbXByb2JhY2nDs24gZXh0cmE6IEFzZWd1cmFyc2UgZGUgcXVlIGVsIGFidWVsbyBleGlzdGUgKHBhcmEgZXZpdGFyIGVycm9yZXMgZW4gZWwgYm9yZGUgZGVsIEFTVClcclxuICAgICAgICAgICAgICAgICAgICAgaihwYXJlbnRTdGF0ZW1lbnRQYXRoKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBqKGN1cnJlbnRJdFBhdGhJbkNvcHkpLnJlbW92ZSgpOyAvLyBGYWxsYmFjayBtZW5vcyBpZGVhbFxyXG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFkdmVydGVuY2lhOiBFc3RydWN0dXJhIGluZXNwZXJhZGEgcGFyYSBibG9xdWUgJ2l0JyBlbiAke2ZpbGVJbmZvLnBhdGh9IChsw61uZWEgJHtjdXJyZW50TG9jPy5zdGFydD8ubGluZX0pLiBSZXZpc2UgZWwgYXJjaGl2byAke2luZGV4ICsgMX0uYCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZWxpbWluYW5kbyBibG9xdWUgJ2l0JyAobMOtbmVhICR7Y3VycmVudExvYz8uc3RhcnQ/LmxpbmV9KSBlbiAke2ZpbGVJbmZvLnBhdGh9IHBhcmEgYXJjaGl2byAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVsc2U6IExhcyB1YmljYWNpb25lcyBjb2luY2lkZW4gLT4gRXN0ZSBlcyBlbCBub2RvIGEgY29uc2VydmFyLCBOTyBIQUNFUiBOQURBLlxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gNS4gR2VuZXJhciBjw7NkaWdvIGZ1ZW50ZSBkZXNkZSBlbCBBU1QgbW9kaWZpY2Fkb1xyXG4gICAgY29uc3Qgb3V0cHV0U291cmNlID0gYXN0Q29weS50b1NvdXJjZSh7IHF1b3RlOiAnc2luZ2xlJywgdHJhaWxpbmdDb21tYTogdHJ1ZSB9KTtcclxuXHJcbiAgICAvLyA2LiBDb25zdHJ1aXIgbnVldm8gbm9tYnJlIGRlIGFyY2hpdm9cclxuICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gYCR7YmFzZU5hbWV9JHtpbmRleCArIDF9JHtleHR9YDtcclxuICAgIGNvbnN0IG5ld0ZpbGVQYXRoID0gcGF0aC5qb2luKGRpciwgbmV3RmlsZU5hbWUpO1xyXG5cclxuICAgIC8vIDcuIEVzY3JpYmlyIGVsIG51ZXZvIGFyY2hpdm9cclxuICAgIHRyeSB7XHJcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMobmV3RmlsZVBhdGgsIG91dHB1dFNvdXJjZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGAgICBDcmVhZG86ICR7bmV3RmlsZVBhdGh9YCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBlc2NyaWJpZW5kbyBhcmNoaXZvICR7bmV3RmlsZVBhdGh9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gSW1wb3J0YW50ZTogRGV2b2x2ZXIgdW5kZWZpbmVkL251bGwgcGFyYSBubyBtb2RpZmljYXIgZWwgb3JpZ2luYWxcclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vLyBPcGNpb25hbCBwZXJvIHJlY29tZW5kYWRvIHNpIG5vIHVzYXMgLS1wYXJzZXI9dHMgZW4gbGEgbMOtbmVhIGRlIGNvbWFuZG9zXHJcbi8vIGV4cG9ydCBjb25zdCBwYXJzZXIgPSAndHMnOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsSUFBQUEsR0FBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsS0FBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBQXdCLFNBQUFELHVCQUFBRyxDQUFBLFdBQUFBLENBQUEsSUFBQUEsQ0FBQSxDQUFBQyxVQUFBLEdBQUFELENBQUEsS0FBQUUsT0FBQSxFQUFBRixDQUFBO0FBRnhCOztBQUlBO0FBQ0E7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","map":{"version":3,"names":["_fs","_interopRequireDefault","require","_path","e","__esModule","default","locationsAreEqual","locA","locB","start","line","column","end","console","error","transformer","fileInfo","api","j","jscodeshift","root","source","itPaths","find","CallExpression","callee","name","paths","length","undefined","log","path","originalPath","dir","dirname","ext","extname","baseName","basename","forEach","targetItPath","index","astCopy","allItPathsInCopy","targetLoc","node","loc","currentItPathInCopy","currentLoc","_parentStatementPath$","parentStatementPath","parentPath","type","remove","_currentLoc$start","warn","_currentLoc$start2","outputSource","toSource","quote","trailingComma","newFileName","newFilePath","join","fs","writeFileSync"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\30_04_25-15_05_25\\splitITJCodeShift\\","sources":["split-specs2.js"],"sourcesContent":["// split-specs.js\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\n// --- Helper Function ---\r\n// Compara si dos objetos de ubicación AST son iguales\r\nconst locationsAreEqual = (locA, locB) => {\r\n    if (!locA || !locB) return false; // Safety check si falta info de ubicación\r\n    try {\r\n        return (\r\n            locA.start.line === locB.start.line &&\r\n            locA.start.column === locB.start.column &&\r\n            locA.end.line === locB.end.line &&\r\n            locA.end.column === locB.end.column\r\n        );\r\n    } catch(e) {\r\n        // En caso de error accediendo a las propiedades (muy raro)\r\n        console.error(\"Error comparando localizaciones:\", e);\r\n        return false;\r\n    }\r\n};\r\n// --- Fin Helper ---\r\n\r\n\r\n// Función principal del transformador de JSCodeshift\r\nexport default function transformer(fileInfo, api) {\r\n  const j = api.jscodeshift;\r\n  const root = j(fileInfo.source); // Parsea el código fuente original\r\n\r\n  // Encuentra todos los nodos de llamada a la función 'it' en el AST original\r\n  const itPaths = root.find(j.CallExpression, {\r\n    callee: { name: 'it' },\r\n  }).paths();\r\n\r\n  // Si no hay bloques 'it' o solo hay uno, no hacemos nada con este archivo.\r\n  if (itPaths.length <= 1) {\r\n    // console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it'. No se requiere división.`);\r\n    // Devolver null/undefined hace que jscodeshift lo cuente como 'skipped'\r\n    return undefined;\r\n  }\r\n\r\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\r\n\r\n  const originalPath = fileInfo.path;\r\n  const dir = path.dirname(originalPath);\r\n  const ext = path.extname(originalPath);\r\n  const baseName = path.basename(originalPath, ext);\r\n\r\n  // --- Generación de un archivo por cada bloque 'it' ---\r\n  itPaths.forEach((targetItPath, index) => {\r\n    // 1. Crear una copia FRESCA del AST original para CADA archivo de salida\r\n    const astCopy = j(fileInfo.source);\r\n\r\n    // 2. Encontrar TODOS los 'it' DENTRO DE ESTA COPIA del AST\r\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\r\n        callee: { name: 'it' },\r\n      }).paths();\r\n\r\n    // 3. Obtener la ubicación del nodo 'it' que queremos MANTENER (del AST original)\r\n    const targetLoc = targetItPath.node.loc;\r\n\r\n    // Seguridad: Si por alguna razón el nodo original no tiene 'loc', no podemos continuar esta iteración.\r\n    if (!targetLoc) {\r\n        console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\r\n        return; // Saltar a la siguiente iteración del forEach\r\n    }\r\n\r\n    // 4. Eliminar TODOS los otros bloques 'it' cuya ubicación NO COINCIDA con targetLoc\r\n    allItPathsInCopy.forEach(currentItPathInCopy => {\r\n        const currentLoc = currentItPathInCopy.node.loc;\r\n\r\n        // Si las ubicaciones NO coinciden, ESTE es un nodo para eliminar\r\n        if (!locationsAreEqual(currentLoc, targetLoc)) {\r\n            try {\r\n                // Intentar eliminar el 'statement' padre (usualmente ExpressionStatement)\r\n                 const parentStatementPath = currentItPathInCopy.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement' && parentStatementPath.parentPath?.node?.type) {\r\n                     // Comprobación extra: Asegurarse de que el abuelo existe (para evitar errores en el borde del AST)\r\n                     j(parentStatementPath).remove();\r\n                 } else {\r\n                     j(currentItPathInCopy).remove(); // Fallback menos ideal\r\n                     console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc?.start?.line}). Revise el archivo ${index + 1}.`);\r\n                 }\r\n            } catch (error) {\r\n                console.error(`Error eliminando bloque 'it' (línea ${currentLoc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n            }\r\n        }\r\n        // Else: Las ubicaciones coinciden -> Este es el nodo a conservar, NO HACER NADA.\r\n    });\r\n\r\n    // 5. Generar código fuente desde el AST modificado\r\n    const outputSource = astCopy.toSource({ quote: 'single', trailingComma: true });\r\n\r\n    // 6. Construir nuevo nombre de archivo\r\n    const newFileName = `${baseName}${index + 1}${ext}`;\r\n    const newFilePath = path.join(dir, newFileName);\r\n\r\n    // 7. Escribir el nuevo archivo\r\n    try {\r\n      fs.writeFileSync(newFilePath, outputSource);\r\n      console.log(`   Creado: ${newFilePath}`);\r\n    } catch (error) {\r\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\r\n    }\r\n  });\r\n\r\n  // Importante: Devolver undefined/null para no modificar el original\r\n  return undefined;\r\n}\r\n\r\n// Opcional pero recomendado si no usas --parser=ts en la línea de comandos\r\n// export const parser = 'ts';"],"mappings":"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","ignoreList":[]}},"mtime":1746462508812},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\split-specs3.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformer;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n// split-specs.js\n\n// --- Helper Function ---\nconst locationsAreEqual = (locA, locB) => {\n  if (!locA || !locB) return false;\n  try {\n    return locA.start.line === locB.start.line && locA.start.column === locB.start.column && locA.end.line === locB.end.line && locA.end.column === locB.end.column;\n  } catch (e) {\n    console.error(\"Error comparando localizaciones:\", e);\n    return false;\n  }\n};\n// --- Fin Helper ---\n\nfunction transformer(fileInfo, api) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n  const itPaths = root.find(j.CallExpression, {\n    callee: {\n      name: 'it'\n    }\n  }).paths();\n  if (itPaths.length <= 1) {\n    return undefined;\n  }\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\n  const originalPath = fileInfo.path;\n  const dir = _path.default.dirname(originalPath);\n  const ext = _path.default.extname(originalPath);\n  const baseName = _path.default.basename(originalPath, ext);\n  itPaths.forEach((targetItPath, index) => {\n    // 1. Crear copia fresca del AST\n    const astCopy = j(fileInfo.source);\n\n    // 2. Encontrar todos los 'it' en la copia\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\n      callee: {\n        name: 'it'\n      }\n    }).paths();\n\n    // 3. Obtener la ubicación del 'it' a conservar\n    const targetLoc = targetItPath.node.loc;\n    if (!targetLoc) {\n      console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\n      return;\n    }\n\n    // 4. Eliminar los 'it' cuya ubicación NO COINCIDA\n    allItPathsInCopy.forEach(currentItPathInCopy => {\n      const currentLoc = currentItPathInCopy.node.loc;\n      if (!locationsAreEqual(currentLoc, targetLoc)) {\n        try {\n          var _parentStatementPath$;\n          const parentStatementPath = currentItPathInCopy.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement' && (_parentStatementPath$ = parentStatementPath.parentPath) !== null && _parentStatementPath$ !== void 0 && (_parentStatementPath$ = _parentStatementPath$.node) !== null && _parentStatementPath$ !== void 0 && _parentStatementPath$.type) {\n            j(parentStatementPath).remove();\n          } else {\n            var _currentLoc$start;\n            j(currentItPathInCopy).remove();\n            console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start = currentLoc.start) === null || _currentLoc$start === void 0 ? void 0 : _currentLoc$start.line}). Revise el archivo ${index + 1}.`);\n          }\n        } catch (error) {\n          var _currentLoc$start2;\n          console.error(`Error eliminando bloque 'it' (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start2 = currentLoc.start) === null || _currentLoc$start2 === void 0 ? void 0 : _currentLoc$start2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\n        }\n      }\n    });\n\n    // 5. --- NUEVO PASO: Eliminar bloques 'describe' vacíos ---\n    try {\n      const describePaths = astCopy.find(j.CallExpression, {\n        callee: {\n          name: 'describe'\n        }\n      }).paths();\n\n      // Iterar en REVERSA es importante al eliminar nodos para no afectar índices/paths\n      describePaths.reverse().forEach(describePath => {\n        let isEmpty = false;\n        try {\n          // Acceder al cuerpo (BlockStatement) de la función del describe\n          const describeFunc = describePath.node.arguments[1]; // El callback es usualmente el 2º argumento\n          let blockStatementNode;\n          if (describeFunc && (describeFunc.type === 'FunctionExpression' || describeFunc.type === 'ArrowFunctionExpression') && describeFunc.body.type === 'BlockStatement') {\n            blockStatementNode = describeFunc.body;\n          } else {\n            var _describePath$node$lo;\n            // Si la estructura no es la esperada, no lo consideramos vacío por seguridad\n            console.warn(`Advertencia: Estructura inesperada en describe (línea ${(_describePath$node$lo = describePath.node.loc) === null || _describePath$node$lo === void 0 || (_describePath$node$lo = _describePath$node$lo.start) === null || _describePath$node$lo === void 0 ? void 0 : _describePath$node$lo.line}) en ${fileInfo.path} para archivo ${index + 1}. No se limpiará.`);\n            return; // Saltar al siguiente describe\n          }\n\n          // Comprobar si el cuerpo contiene llamadas relevantes\n          const relevantCalls = j(blockStatementNode).find(j.CallExpression, node => {\n            var _node$callee;\n            return ['it', 'describe', 'beforeEach', 'afterEach', 'beforeAll', 'afterAll'].includes((_node$callee = node.callee) === null || _node$callee === void 0 ? void 0 : _node$callee.name);\n          } // Optional chaining por si callee no existe\n          );\n          if (relevantCalls.length === 0) {\n            // No hay llamadas relevantes, consideramos el describe vacío\n            isEmpty = true;\n          }\n        } catch (findError) {\n          var _describePath$node$lo2;\n          console.error(`Error inspeccionando cuerpo de describe (línea ${(_describePath$node$lo2 = describePath.node.loc) === null || _describePath$node$lo2 === void 0 || (_describePath$node$lo2 = _describePath$node$lo2.start) === null || _describePath$node$lo2 === void 0 ? void 0 : _describePath$node$lo2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, findError);\n          // No eliminar si hubo error al inspeccionar\n          isEmpty = false;\n        }\n        if (isEmpty) {\n          // Eliminar el ExpressionStatement que contiene la llamada al describe\n          const parentStatementPath = describePath.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement') {\n            var _describePath$node$lo3;\n            j(parentStatementPath).remove();\n            console.log(`   - Describe vacío eliminado (línea ${(_describePath$node$lo3 = describePath.node.loc) === null || _describePath$node$lo3 === void 0 || (_describePath$node$lo3 = _describePath$node$lo3.start) === null || _describePath$node$lo3 === void 0 ? void 0 : _describePath$node$lo3.line}) en archivo ${index + 1}`);\n          } else {\n            var _describePath$node$lo4;\n            console.warn(`Advertencia: Describe vacío (línea ${(_describePath$node$lo4 = describePath.node.loc) === null || _describePath$node$lo4 === void 0 || (_describePath$node$lo4 = _describePath$node$lo4.start) === null || _describePath$node$lo4 === void 0 ? void 0 : _describePath$node$lo4.line}) no estaba en un ExpressionStatement directo. No se eliminó.`);\n          }\n        }\n      });\n    } catch (error) {\n      console.error(`Error durante la limpieza de bloques describe en ${fileInfo.path} para archivo ${index + 1}:`, error);\n    }\n    // --- FIN NUEVO PASO ---\n\n    // 6. Generar código fuente desde el AST modificado (ahora también sin describes vacíos)\n    const outputSource = astCopy.toSource({\n      quote: 'single',\n      trailingComma: true\n    });\n\n    // 7. Construir nuevo nombre de archivo\n    const newFileName = `${baseName}${index + 1}${ext}`;\n    const newFilePath = _path.default.join(dir, newFileName);\n\n    // 8. Escribir el nuevo archivo\n    try {\n      _fs.default.writeFileSync(newFilePath, outputSource);\n      console.log(`   Creado: ${newFilePath}`);\n    } catch (error) {\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\n    }\n  });\n\n  // Devolver undefined/null para no modificar el original\n  return undefined;\n}\n\n// export const parser = 'ts';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZnMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9wYXRoIiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwibG9jYXRpb25zQXJlRXF1YWwiLCJsb2NBIiwibG9jQiIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsImVuZCIsImNvbnNvbGUiLCJlcnJvciIsInRyYW5zZm9ybWVyIiwiZmlsZUluZm8iLCJhcGkiLCJqIiwianNjb2Rlc2hpZnQiLCJyb290Iiwic291cmNlIiwiaXRQYXRocyIsImZpbmQiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsIm5hbWUiLCJwYXRocyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImxvZyIsInBhdGgiLCJvcmlnaW5hbFBhdGgiLCJkaXIiLCJkaXJuYW1lIiwiZXh0IiwiZXh0bmFtZSIsImJhc2VOYW1lIiwiYmFzZW5hbWUiLCJmb3JFYWNoIiwidGFyZ2V0SXRQYXRoIiwiaW5kZXgiLCJhc3RDb3B5IiwiYWxsSXRQYXRoc0luQ29weSIsInRhcmdldExvYyIsIm5vZGUiLCJsb2MiLCJjdXJyZW50SXRQYXRoSW5Db3B5IiwiY3VycmVudExvYyIsIl9wYXJlbnRTdGF0ZW1lbnRQYXRoJCIsInBhcmVudFN0YXRlbWVudFBhdGgiLCJwYXJlbnRQYXRoIiwidHlwZSIsInJlbW92ZSIsIl9jdXJyZW50TG9jJHN0YXJ0Iiwid2FybiIsIl9jdXJyZW50TG9jJHN0YXJ0MiIsImRlc2NyaWJlUGF0aHMiLCJyZXZlcnNlIiwiZGVzY3JpYmVQYXRoIiwiaXNFbXB0eSIsImRlc2NyaWJlRnVuYyIsImFyZ3VtZW50cyIsImJsb2NrU3RhdGVtZW50Tm9kZSIsImJvZHkiLCJfZGVzY3JpYmVQYXRoJG5vZGUkbG8iLCJyZWxldmFudENhbGxzIiwiX25vZGUkY2FsbGVlIiwiaW5jbHVkZXMiLCJmaW5kRXJyb3IiLCJfZGVzY3JpYmVQYXRoJG5vZGUkbG8yIiwiX2Rlc2NyaWJlUGF0aCRub2RlJGxvMyIsIl9kZXNjcmliZVBhdGgkbm9kZSRsbzQiLCJvdXRwdXRTb3VyY2UiLCJ0b1NvdXJjZSIsInF1b3RlIiwidHJhaWxpbmdDb21tYSIsIm5ld0ZpbGVOYW1lIiwibmV3RmlsZVBhdGgiLCJqb2luIiwiZnMiLCJ3cml0ZUZpbGVTeW5jIl0sInNvdXJjZVJvb3QiOiJDOlxcVXNlcnNcXHhhYmlhXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcNC5NYWlsYVxcVEZHLUJlc3RlbGFrb2FrXFxCZXN0ZWxha29ha1xcMzBfMDRfMjUtMTVfMDVfMjVcXHNwbGl0SVRKQ29kZVNoaWZ0XFwiLCJzb3VyY2VzIjpbInNwbGl0LXNwZWNzMy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcGxpdC1zcGVjcy5qc1xyXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuXHJcbi8vIC0tLSBIZWxwZXIgRnVuY3Rpb24gLS0tXHJcbmNvbnN0IGxvY2F0aW9uc0FyZUVxdWFsID0gKGxvY0EsIGxvY0IpID0+IHtcclxuICAgIGlmICghbG9jQSB8fCAhbG9jQikgcmV0dXJuIGZhbHNlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBsb2NBLnN0YXJ0LmxpbmUgPT09IGxvY0Iuc3RhcnQubGluZSAmJlxyXG4gICAgICAgICAgICBsb2NBLnN0YXJ0LmNvbHVtbiA9PT0gbG9jQi5zdGFydC5jb2x1bW4gJiZcclxuICAgICAgICAgICAgbG9jQS5lbmQubGluZSA9PT0gbG9jQi5lbmQubGluZSAmJlxyXG4gICAgICAgICAgICBsb2NBLmVuZC5jb2x1bW4gPT09IGxvY0IuZW5kLmNvbHVtblxyXG4gICAgICAgICk7XHJcbiAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29tcGFyYW5kbyBsb2NhbGl6YWNpb25lczpcIiwgZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG4vLyAtLS0gRmluIEhlbHBlciAtLS1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybWVyKGZpbGVJbmZvLCBhcGkpIHtcclxuICBjb25zdCBqID0gYXBpLmpzY29kZXNoaWZ0O1xyXG4gIGNvbnN0IHJvb3QgPSBqKGZpbGVJbmZvLnNvdXJjZSk7XHJcblxyXG4gIGNvbnN0IGl0UGF0aHMgPSByb290LmZpbmQoai5DYWxsRXhwcmVzc2lvbiwge1xyXG4gICAgY2FsbGVlOiB7IG5hbWU6ICdpdCcgfSxcclxuICB9KS5wYXRocygpO1xyXG5cclxuICBpZiAoaXRQYXRocy5sZW5ndGggPD0gMSkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIGNvbnNvbGUubG9nKGAtPiBBcmNoaXZvICR7ZmlsZUluZm8ucGF0aH06ICR7aXRQYXRocy5sZW5ndGh9IGJsb3F1ZShzKSAnaXQnIGVuY29udHJhZG9zLiBHZW5lcmFuZG8gYXJjaGl2b3MgaW5kaXZpZHVhbGVzLi4uYCk7XHJcblxyXG4gIGNvbnN0IG9yaWdpbmFsUGF0aCA9IGZpbGVJbmZvLnBhdGg7XHJcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKG9yaWdpbmFsUGF0aCk7XHJcbiAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKG9yaWdpbmFsUGF0aCk7XHJcbiAgY29uc3QgYmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKG9yaWdpbmFsUGF0aCwgZXh0KTtcclxuXHJcbiAgaXRQYXRocy5mb3JFYWNoKCh0YXJnZXRJdFBhdGgsIGluZGV4KSA9PiB7XHJcbiAgICAvLyAxLiBDcmVhciBjb3BpYSBmcmVzY2EgZGVsIEFTVFxyXG4gICAgY29uc3QgYXN0Q29weSA9IGooZmlsZUluZm8uc291cmNlKTtcclxuXHJcbiAgICAvLyAyLiBFbmNvbnRyYXIgdG9kb3MgbG9zICdpdCcgZW4gbGEgY29waWFcclxuICAgIGNvbnN0IGFsbEl0UGF0aHNJbkNvcHkgPSBhc3RDb3B5LmZpbmQoai5DYWxsRXhwcmVzc2lvbiwge1xyXG4gICAgICAgIGNhbGxlZTogeyBuYW1lOiAnaXQnIH0sXHJcbiAgICAgIH0pLnBhdGhzKCk7XHJcblxyXG4gICAgLy8gMy4gT2J0ZW5lciBsYSB1YmljYWNpw7NuIGRlbCAnaXQnIGEgY29uc2VydmFyXHJcbiAgICBjb25zdCB0YXJnZXRMb2MgPSB0YXJnZXRJdFBhdGgubm9kZS5sb2M7XHJcbiAgICBpZiAoIXRhcmdldExvYykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIENyw610aWNvOiBGYWx0YSBpbmZvcm1hY2nDs24gZGUgdWJpY2FjacOzbiBwYXJhIGVsIGJsb3F1ZSAnaXQnICjDrW5kaWNlICR7aW5kZXh9KSBlbiAke2ZpbGVJbmZvLnBhdGh9LiBObyBzZSBwdWVkZSBnZW5lcmFyIGFyY2hpdm8gJHtpbmRleCArIDF9LmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyA0LiBFbGltaW5hciBsb3MgJ2l0JyBjdXlhIHViaWNhY2nDs24gTk8gQ09JTkNJREFcclxuICAgIGFsbEl0UGF0aHNJbkNvcHkuZm9yRWFjaChjdXJyZW50SXRQYXRoSW5Db3B5ID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50TG9jID0gY3VycmVudEl0UGF0aEluQ29weS5ub2RlLmxvYztcclxuICAgICAgICBpZiAoIWxvY2F0aW9uc0FyZUVxdWFsKGN1cnJlbnRMb2MsIHRhcmdldExvYykpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRTdGF0ZW1lbnRQYXRoID0gY3VycmVudEl0UGF0aEluQ29weS5wYXJlbnRQYXRoO1xyXG4gICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZW1lbnRQYXRoLm5vZGUudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICYmIHBhcmVudFN0YXRlbWVudFBhdGgucGFyZW50UGF0aD8ubm9kZT8udHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICBqKHBhcmVudFN0YXRlbWVudFBhdGgpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGooY3VycmVudEl0UGF0aEluQ29weSkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQWR2ZXJ0ZW5jaWE6IEVzdHJ1Y3R1cmEgaW5lc3BlcmFkYSBwYXJhIGJsb3F1ZSAnaXQnIGVuICR7ZmlsZUluZm8ucGF0aH0gKGzDrW5lYSAke2N1cnJlbnRMb2M/LnN0YXJ0Py5saW5lfSkuIFJldmlzZSBlbCBhcmNoaXZvICR7aW5kZXggKyAxfS5gKTtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBlbGltaW5hbmRvIGJsb3F1ZSAnaXQnIChsw61uZWEgJHtjdXJyZW50TG9jPy5zdGFydD8ubGluZX0pIGVuICR7ZmlsZUluZm8ucGF0aH0gcGFyYSBhcmNoaXZvICR7aW5kZXggKyAxfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyA1LiAtLS0gTlVFVk8gUEFTTzogRWxpbWluYXIgYmxvcXVlcyAnZGVzY3JpYmUnIHZhY8Otb3MgLS0tXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaWJlUGF0aHMgPSBhc3RDb3B5LmZpbmQoai5DYWxsRXhwcmVzc2lvbiwge1xyXG4gICAgICAgICAgICBjYWxsZWU6IHsgbmFtZTogJ2Rlc2NyaWJlJyB9XHJcbiAgICAgICAgfSkucGF0aHMoKTtcclxuXHJcbiAgICAgICAgLy8gSXRlcmFyIGVuIFJFVkVSU0EgZXMgaW1wb3J0YW50ZSBhbCBlbGltaW5hciBub2RvcyBwYXJhIG5vIGFmZWN0YXIgw61uZGljZXMvcGF0aHNcclxuICAgICAgICBkZXNjcmliZVBhdGhzLnJldmVyc2UoKS5mb3JFYWNoKGRlc2NyaWJlUGF0aCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpc0VtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBY2NlZGVyIGFsIGN1ZXJwbyAoQmxvY2tTdGF0ZW1lbnQpIGRlIGxhIGZ1bmNpw7NuIGRlbCBkZXNjcmliZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpYmVGdW5jID0gZGVzY3JpYmVQYXRoLm5vZGUuYXJndW1lbnRzWzFdOyAvLyBFbCBjYWxsYmFjayBlcyB1c3VhbG1lbnRlIGVsIDLCuiBhcmd1bWVudG9cclxuICAgICAgICAgICAgICAgIGxldCBibG9ja1N0YXRlbWVudE5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaWJlRnVuYyAmJiAoZGVzY3JpYmVGdW5jLnR5cGUgPT09ICdGdW5jdGlvbkV4cHJlc3Npb24nIHx8IGRlc2NyaWJlRnVuYy50eXBlID09PSAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nKSAmJiBkZXNjcmliZUZ1bmMuYm9keS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJsb2NrU3RhdGVtZW50Tm9kZSA9IGRlc2NyaWJlRnVuYy5ib2R5O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgLy8gU2kgbGEgZXN0cnVjdHVyYSBubyBlcyBsYSBlc3BlcmFkYSwgbm8gbG8gY29uc2lkZXJhbW9zIHZhY8OtbyBwb3Igc2VndXJpZGFkXHJcbiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQWR2ZXJ0ZW5jaWE6IEVzdHJ1Y3R1cmEgaW5lc3BlcmFkYSBlbiBkZXNjcmliZSAobMOtbmVhICR7ZGVzY3JpYmVQYXRoLm5vZGUubG9jPy5zdGFydD8ubGluZX0pIGVuICR7ZmlsZUluZm8ucGF0aH0gcGFyYSBhcmNoaXZvICR7aW5kZXggKyAxfS4gTm8gc2UgbGltcGlhcsOhLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFNhbHRhciBhbCBzaWd1aWVudGUgZGVzY3JpYmVcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wcm9iYXIgc2kgZWwgY3VlcnBvIGNvbnRpZW5lIGxsYW1hZGFzIHJlbGV2YW50ZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbGV2YW50Q2FsbHMgPSBqKGJsb2NrU3RhdGVtZW50Tm9kZSkuZmluZChqLkNhbGxFeHByZXNzaW9uLCBub2RlID0+XHJcbiAgICAgICAgICAgICAgICAgICAgWydpdCcsICdkZXNjcmliZScsICdiZWZvcmVFYWNoJywgJ2FmdGVyRWFjaCcsICdiZWZvcmVBbGwnLCAnYWZ0ZXJBbGwnXS5pbmNsdWRlcyhub2RlLmNhbGxlZT8ubmFtZSkgLy8gT3B0aW9uYWwgY2hhaW5pbmcgcG9yIHNpIGNhbGxlZSBubyBleGlzdGVcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlbGV2YW50Q2FsbHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gaGF5IGxsYW1hZGFzIHJlbGV2YW50ZXMsIGNvbnNpZGVyYW1vcyBlbCBkZXNjcmliZSB2YWPDrW9cclxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGZpbmRFcnJvcil7XHJcbiAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW5zcGVjY2lvbmFuZG8gY3VlcnBvIGRlIGRlc2NyaWJlIChsw61uZWEgJHtkZXNjcmliZVBhdGgubm9kZS5sb2M/LnN0YXJ0Py5saW5lfSkgZW4gJHtmaWxlSW5mby5wYXRofSBwYXJhIGFyY2hpdm8gJHtpbmRleCArIDF9OmAsIGZpbmRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgLy8gTm8gZWxpbWluYXIgc2kgaHVibyBlcnJvciBhbCBpbnNwZWNjaW9uYXJcclxuICAgICAgICAgICAgICAgICBpc0VtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgIC8vIEVsaW1pbmFyIGVsIEV4cHJlc3Npb25TdGF0ZW1lbnQgcXVlIGNvbnRpZW5lIGxhIGxsYW1hZGEgYWwgZGVzY3JpYmVcclxuICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRTdGF0ZW1lbnRQYXRoID0gZGVzY3JpYmVQYXRoLnBhcmVudFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlbWVudFBhdGgubm9kZS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgaihwYXJlbnRTdGF0ZW1lbnRQYXRoKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIC0gRGVzY3JpYmUgdmFjw61vIGVsaW1pbmFkbyAobMOtbmVhICR7ZGVzY3JpYmVQYXRoLm5vZGUubG9jPy5zdGFydD8ubGluZX0pIGVuIGFyY2hpdm8gJHtpbmRleCArIDF9YCk7XHJcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBZHZlcnRlbmNpYTogRGVzY3JpYmUgdmFjw61vIChsw61uZWEgJHtkZXNjcmliZVBhdGgubm9kZS5sb2M/LnN0YXJ0Py5saW5lfSkgbm8gZXN0YWJhIGVuIHVuIEV4cHJlc3Npb25TdGF0ZW1lbnQgZGlyZWN0by4gTm8gc2UgZWxpbWluw7MuYCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmFudGUgbGEgbGltcGllemEgZGUgYmxvcXVlcyBkZXNjcmliZSBlbiAke2ZpbGVJbmZvLnBhdGh9IHBhcmEgYXJjaGl2byAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tIEZJTiBOVUVWTyBQQVNPIC0tLVxyXG5cclxuXHJcbiAgICAvLyA2LiBHZW5lcmFyIGPDs2RpZ28gZnVlbnRlIGRlc2RlIGVsIEFTVCBtb2RpZmljYWRvIChhaG9yYSB0YW1iacOpbiBzaW4gZGVzY3JpYmVzIHZhY8Otb3MpXHJcbiAgICBjb25zdCBvdXRwdXRTb3VyY2UgPSBhc3RDb3B5LnRvU291cmNlKHsgcXVvdGU6ICdzaW5nbGUnLCB0cmFpbGluZ0NvbW1hOiB0cnVlIH0pO1xyXG5cclxuICAgIC8vIDcuIENvbnN0cnVpciBudWV2byBub21icmUgZGUgYXJjaGl2b1xyXG4gICAgY29uc3QgbmV3RmlsZU5hbWUgPSBgJHtiYXNlTmFtZX0ke2luZGV4ICsgMX0ke2V4dH1gO1xyXG4gICAgY29uc3QgbmV3RmlsZVBhdGggPSBwYXRoLmpvaW4oZGlyLCBuZXdGaWxlTmFtZSk7XHJcblxyXG4gICAgLy8gOC4gRXNjcmliaXIgZWwgbnVldm8gYXJjaGl2b1xyXG4gICAgdHJ5IHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyhuZXdGaWxlUGF0aCwgb3V0cHV0U291cmNlKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIENyZWFkbzogJHtuZXdGaWxlUGF0aH1gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVzY3JpYmllbmRvIGFyY2hpdm8gJHtuZXdGaWxlUGF0aH06YCwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBEZXZvbHZlciB1bmRlZmluZWQvbnVsbCBwYXJhIG5vIG1vZGlmaWNhciBlbCBvcmlnaW5hbFxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8vIGV4cG9ydCBjb25zdCBwYXJzZXIgPSAndHMnOyJd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","map":{"version":3,"names":["_fs","_interopRequireDefault","require","_path","e","__esModule","default","locationsAreEqual","locA","locB","start","line","column","end","console","error","transformer","fileInfo","api","j","jscodeshift","root","source","itPaths","find","CallExpression","callee","name","paths","length","undefined","log","path","originalPath","dir","dirname","ext","extname","baseName","basename","forEach","targetItPath","index","astCopy","allItPathsInCopy","targetLoc","node","loc","currentItPathInCopy","currentLoc","_parentStatementPath$","parentStatementPath","parentPath","type","remove","_currentLoc$start","warn","_currentLoc$start2","describePaths","reverse","describePath","isEmpty","describeFunc","arguments","blockStatementNode","body","_describePath$node$lo","relevantCalls","_node$callee","includes","findError","_describePath$node$lo2","_describePath$node$lo3","_describePath$node$lo4","outputSource","toSource","quote","trailingComma","newFileName","newFilePath","join","fs","writeFileSync"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\30_04_25-15_05_25\\splitITJCodeShift\\","sources":["split-specs3.js"],"sourcesContent":["// split-specs.js\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\n// --- Helper Function ---\r\nconst locationsAreEqual = (locA, locB) => {\r\n    if (!locA || !locB) return false;\r\n    try {\r\n        return (\r\n            locA.start.line === locB.start.line &&\r\n            locA.start.column === locB.start.column &&\r\n            locA.end.line === locB.end.line &&\r\n            locA.end.column === locB.end.column\r\n        );\r\n    } catch(e) {\r\n        console.error(\"Error comparando localizaciones:\", e);\r\n        return false;\r\n    }\r\n};\r\n// --- Fin Helper ---\r\n\r\nexport default function transformer(fileInfo, api) {\r\n  const j = api.jscodeshift;\r\n  const root = j(fileInfo.source);\r\n\r\n  const itPaths = root.find(j.CallExpression, {\r\n    callee: { name: 'it' },\r\n  }).paths();\r\n\r\n  if (itPaths.length <= 1) {\r\n    return undefined;\r\n  }\r\n\r\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\r\n\r\n  const originalPath = fileInfo.path;\r\n  const dir = path.dirname(originalPath);\r\n  const ext = path.extname(originalPath);\r\n  const baseName = path.basename(originalPath, ext);\r\n\r\n  itPaths.forEach((targetItPath, index) => {\r\n    // 1. Crear copia fresca del AST\r\n    const astCopy = j(fileInfo.source);\r\n\r\n    // 2. Encontrar todos los 'it' en la copia\r\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\r\n        callee: { name: 'it' },\r\n      }).paths();\r\n\r\n    // 3. Obtener la ubicación del 'it' a conservar\r\n    const targetLoc = targetItPath.node.loc;\r\n    if (!targetLoc) {\r\n        console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\r\n        return;\r\n    }\r\n\r\n    // 4. Eliminar los 'it' cuya ubicación NO COINCIDA\r\n    allItPathsInCopy.forEach(currentItPathInCopy => {\r\n        const currentLoc = currentItPathInCopy.node.loc;\r\n        if (!locationsAreEqual(currentLoc, targetLoc)) {\r\n            try {\r\n                 const parentStatementPath = currentItPathInCopy.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement' && parentStatementPath.parentPath?.node?.type) {\r\n                     j(parentStatementPath).remove();\r\n                 } else {\r\n                     j(currentItPathInCopy).remove();\r\n                     console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc?.start?.line}). Revise el archivo ${index + 1}.`);\r\n                 }\r\n            } catch (error) {\r\n                console.error(`Error eliminando bloque 'it' (línea ${currentLoc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n            }\r\n        }\r\n    });\r\n\r\n    // 5. --- NUEVO PASO: Eliminar bloques 'describe' vacíos ---\r\n    try {\r\n        const describePaths = astCopy.find(j.CallExpression, {\r\n            callee: { name: 'describe' }\r\n        }).paths();\r\n\r\n        // Iterar en REVERSA es importante al eliminar nodos para no afectar índices/paths\r\n        describePaths.reverse().forEach(describePath => {\r\n            let isEmpty = false;\r\n            try {\r\n                // Acceder al cuerpo (BlockStatement) de la función del describe\r\n                const describeFunc = describePath.node.arguments[1]; // El callback es usualmente el 2º argumento\r\n                let blockStatementNode;\r\n\r\n                if (describeFunc && (describeFunc.type === 'FunctionExpression' || describeFunc.type === 'ArrowFunctionExpression') && describeFunc.body.type === 'BlockStatement') {\r\n                     blockStatementNode = describeFunc.body;\r\n                } else {\r\n                     // Si la estructura no es la esperada, no lo consideramos vacío por seguridad\r\n                     console.warn(`Advertencia: Estructura inesperada en describe (línea ${describePath.node.loc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}. No se limpiará.`);\r\n                     return; // Saltar al siguiente describe\r\n                }\r\n\r\n                // Comprobar si el cuerpo contiene llamadas relevantes\r\n                const relevantCalls = j(blockStatementNode).find(j.CallExpression, node =>\r\n                    ['it', 'describe', 'beforeEach', 'afterEach', 'beforeAll', 'afterAll'].includes(node.callee?.name) // Optional chaining por si callee no existe\r\n                );\r\n\r\n                if (relevantCalls.length === 0) {\r\n                    // No hay llamadas relevantes, consideramos el describe vacío\r\n                    isEmpty = true;\r\n                }\r\n\r\n            } catch (findError){\r\n                 console.error(`Error inspeccionando cuerpo de describe (línea ${describePath.node.loc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, findError);\r\n                 // No eliminar si hubo error al inspeccionar\r\n                 isEmpty = false;\r\n            }\r\n\r\n\r\n            if (isEmpty) {\r\n                 // Eliminar el ExpressionStatement que contiene la llamada al describe\r\n                 const parentStatementPath = describePath.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement') {\r\n                     j(parentStatementPath).remove();\r\n                     console.log(`   - Describe vacío eliminado (línea ${describePath.node.loc?.start?.line}) en archivo ${index + 1}`);\r\n                 } else {\r\n                     console.warn(`Advertencia: Describe vacío (línea ${describePath.node.loc?.start?.line}) no estaba en un ExpressionStatement directo. No se eliminó.`);\r\n                 }\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error(`Error durante la limpieza de bloques describe en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n    }\r\n    // --- FIN NUEVO PASO ---\r\n\r\n\r\n    // 6. Generar código fuente desde el AST modificado (ahora también sin describes vacíos)\r\n    const outputSource = astCopy.toSource({ quote: 'single', trailingComma: true });\r\n\r\n    // 7. Construir nuevo nombre de archivo\r\n    const newFileName = `${baseName}${index + 1}${ext}`;\r\n    const newFilePath = path.join(dir, newFileName);\r\n\r\n    // 8. Escribir el nuevo archivo\r\n    try {\r\n      fs.writeFileSync(newFilePath, outputSource);\r\n      console.log(`   Creado: ${newFilePath}`);\r\n    } catch (error) {\r\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\r\n    }\r\n  });\r\n\r\n  // Devolver undefined/null para no modificar el original\r\n  return undefined;\r\n}\r\n\r\n// export const parser = 'ts';"],"mappings":"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","ignoreList":[]}},"mtime":1746464270376},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\split-specs4.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformer;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n// split-specs.js\n\n// --- Helper Function ---\nconst locationsAreEqual = (locA, locB) => {\n  if (!locA || !locB) return false;\n  try {\n    return locA.start.line === locB.start.line && locA.start.column === locB.start.column && locA.end.line === locB.end.line && locA.end.column === locB.end.column;\n  } catch (e) {\n    console.error(\"Error comparando localizaciones:\", e);\n    return false;\n  }\n};\n// --- Fin Helper ---\n\nfunction transformer(fileInfo, api) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n  const itPaths = root.find(j.CallExpression, {\n    callee: {\n      name: 'it'\n    }\n  }).paths();\n  if (itPaths.length <= 1) {\n    return undefined;\n  }\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\n  const originalPath = fileInfo.path;\n  const dir = _path.default.dirname(originalPath);\n  const ext = _path.default.extname(originalPath);\n  const baseName = _path.default.basename(originalPath, ext);\n  itPaths.forEach((targetItPath, index) => {\n    // 1. Crear copia fresca del AST\n    const astCopy = j(fileInfo.source);\n\n    // 2. Encontrar todos los 'it' en la copia\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\n      callee: {\n        name: 'it'\n      }\n    }).paths();\n\n    // 3. Obtener la ubicación del 'it' a conservar\n    const targetLoc = targetItPath.node.loc;\n    if (!targetLoc) {\n      console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\n      return;\n    }\n\n    // 4. Eliminar los 'it' cuya ubicación NO COINCIDA\n    allItPathsInCopy.forEach(currentItPathInCopy => {\n      const currentLoc = currentItPathInCopy.node.loc;\n      if (!locationsAreEqual(currentLoc, targetLoc)) {\n        try {\n          var _parentStatementPath$;\n          const parentStatementPath = currentItPathInCopy.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement' && (_parentStatementPath$ = parentStatementPath.parentPath) !== null && _parentStatementPath$ !== void 0 && (_parentStatementPath$ = _parentStatementPath$.node) !== null && _parentStatementPath$ !== void 0 && _parentStatementPath$.type) {\n            j(parentStatementPath).remove();\n          } else {\n            var _currentLoc$start;\n            j(currentItPathInCopy).remove();\n            console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start = currentLoc.start) === null || _currentLoc$start === void 0 ? void 0 : _currentLoc$start.line}). Revise el archivo ${index + 1}.`);\n          }\n        } catch (error) {\n          var _currentLoc$start2;\n          console.error(`Error eliminando bloque 'it' (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start2 = currentLoc.start) === null || _currentLoc$start2 === void 0 ? void 0 : _currentLoc$start2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\n        }\n      }\n    });\n\n    // 5. --- NUEVO PASO: Eliminar bloques 'describe' vacíos ---\n    try {\n      const describePaths = astCopy.find(j.CallExpression, {\n        callee: {\n          name: 'describe'\n        }\n      }).paths();\n\n      // Iterar en REVERSA es importante al eliminar nodos para no afectar índices/paths\n      describePaths.reverse().forEach(describePath => {\n        let isEmpty = false;\n        try {\n          // Acceder al cuerpo (BlockStatement) de la función del describe\n          const describeFunc = describePath.node.arguments[1]; // El callback es usualmente el 2º argumento\n          let blockStatementNode;\n          if (describeFunc && (describeFunc.type === 'FunctionExpression' || describeFunc.type === 'ArrowFunctionExpression') && describeFunc.body.type === 'BlockStatement') {\n            blockStatementNode = describeFunc.body;\n          } else {\n            var _describePath$node$lo;\n            // Si la estructura no es la esperada, no lo consideramos vacío por seguridad\n            console.warn(`Advertencia: Estructura inesperada en describe (línea ${(_describePath$node$lo = describePath.node.loc) === null || _describePath$node$lo === void 0 || (_describePath$node$lo = _describePath$node$lo.start) === null || _describePath$node$lo === void 0 ? void 0 : _describePath$node$lo.line}) en ${fileInfo.path} para archivo ${index + 1}. No se limpiará.`);\n            return; // Saltar al siguiente describe\n          }\n\n          // Comprobar si el cuerpo contiene llamadas relevantes\n          const relevantCalls = j(blockStatementNode).find(j.CallExpression, node => {\n            var _node$callee;\n            return ['it', 'describe', 'beforeEach', 'afterEach', 'beforeAll', 'afterAll'].includes((_node$callee = node.callee) === null || _node$callee === void 0 ? void 0 : _node$callee.name);\n          } // Optional chaining por si callee no existe\n          );\n          if (relevantCalls.length === 0) {\n            // No hay llamadas relevantes, consideramos el describe vacío\n            isEmpty = true;\n          }\n        } catch (findError) {\n          var _describePath$node$lo2;\n          console.error(`Error inspeccionando cuerpo de describe (línea ${(_describePath$node$lo2 = describePath.node.loc) === null || _describePath$node$lo2 === void 0 || (_describePath$node$lo2 = _describePath$node$lo2.start) === null || _describePath$node$lo2 === void 0 ? void 0 : _describePath$node$lo2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, findError);\n          // No eliminar si hubo error al inspeccionar\n          isEmpty = false;\n        }\n        if (isEmpty) {\n          // Eliminar el ExpressionStatement que contiene la llamada al describe\n          const parentStatementPath = describePath.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement') {\n            var _describePath$node$lo3;\n            j(parentStatementPath).remove();\n            console.log(`   - Describe vacío eliminado (línea ${(_describePath$node$lo3 = describePath.node.loc) === null || _describePath$node$lo3 === void 0 || (_describePath$node$lo3 = _describePath$node$lo3.start) === null || _describePath$node$lo3 === void 0 ? void 0 : _describePath$node$lo3.line}) en archivo ${index + 1}`);\n          } else {\n            var _describePath$node$lo4;\n            console.warn(`Advertencia: Describe vacío (línea ${(_describePath$node$lo4 = describePath.node.loc) === null || _describePath$node$lo4 === void 0 || (_describePath$node$lo4 = _describePath$node$lo4.start) === null || _describePath$node$lo4 === void 0 ? void 0 : _describePath$node$lo4.line}) no estaba en un ExpressionStatement directo. No se eliminó.`);\n          }\n        }\n      });\n    } catch (error) {\n      console.error(`Error durante la limpieza de bloques describe en ${fileInfo.path} para archivo ${index + 1}:`, error);\n    }\n    // --- FIN NUEVO PASO ---\n\n    // 6. Generar código fuente desde el AST modificado (ahora también sin describes vacíos)\n    const outputSource = astCopy.toSource({\n      quote: 'single',\n      trailingComma: true\n    });\n\n    // 7. Construir nuevo nombre de archivo y ruta de directorio de resultados\n    const resultsDir = _path.default.join(dir, 'results'); // Directorio de resultados\n    const newFileName = `${baseName}${index + 1}${ext}`;\n    const newFilePath = _path.default.join(resultsDir, newFileName); // Ruta completa en 'results'\n\n    // 8. Asegurarse de que el directorio 'results' exista\n    try {\n      if (!_fs.default.existsSync(resultsDir)) {\n        _fs.default.mkdirSync(resultsDir, {\n          recursive: true\n        });\n        console.log(`   Directorio 'results' creado en: ${resultsDir}`);\n      }\n    } catch (error) {\n      console.error(`Error creando directorio ${resultsDir}:`, error);\n      return; // No continuar si no se puede crear el directorio\n    }\n\n    // 9. Escribir el nuevo archivo en el directorio 'results'\n    try {\n      _fs.default.writeFileSync(newFilePath, outputSource);\n      console.log(`   Creado: ${newFilePath}`);\n    } catch (error) {\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\n    }\n  });\n\n  // Devolver undefined/null para no modificar el original\n  return undefined;\n}\n\n// export const parser = 'ts';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZnMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9wYXRoIiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwibG9jYXRpb25zQXJlRXF1YWwiLCJsb2NBIiwibG9jQiIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsImVuZCIsImNvbnNvbGUiLCJlcnJvciIsInRyYW5zZm9ybWVyIiwiZmlsZUluZm8iLCJhcGkiLCJqIiwianNjb2Rlc2hpZnQiLCJyb290Iiwic291cmNlIiwiaXRQYXRocyIsImZpbmQiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsIm5hbWUiLCJwYXRocyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImxvZyIsInBhdGgiLCJvcmlnaW5hbFBhdGgiLCJkaXIiLCJkaXJuYW1lIiwiZXh0IiwiZXh0bmFtZSIsImJhc2VOYW1lIiwiYmFzZW5hbWUiLCJmb3JFYWNoIiwidGFyZ2V0SXRQYXRoIiwiaW5kZXgiLCJhc3RDb3B5IiwiYWxsSXRQYXRoc0luQ29weSIsInRhcmdldExvYyIsIm5vZGUiLCJsb2MiLCJjdXJyZW50SXRQYXRoSW5Db3B5IiwiY3VycmVudExvYyIsIl9wYXJlbnRTdGF0ZW1lbnRQYXRoJCIsInBhcmVudFN0YXRlbWVudFBhdGgiLCJwYXJlbnRQYXRoIiwidHlwZSIsInJlbW92ZSIsIl9jdXJyZW50TG9jJHN0YXJ0Iiwid2FybiIsIl9jdXJyZW50TG9jJHN0YXJ0MiIsImRlc2NyaWJlUGF0aHMiLCJyZXZlcnNlIiwiZGVzY3JpYmVQYXRoIiwiaXNFbXB0eSIsImRlc2NyaWJlRnVuYyIsImFyZ3VtZW50cyIsImJsb2NrU3RhdGVtZW50Tm9kZSIsImJvZHkiLCJfZGVzY3JpYmVQYXRoJG5vZGUkbG8iLCJyZWxldmFudENhbGxzIiwiX25vZGUkY2FsbGVlIiwiaW5jbHVkZXMiLCJmaW5kRXJyb3IiLCJfZGVzY3JpYmVQYXRoJG5vZGUkbG8yIiwiX2Rlc2NyaWJlUGF0aCRub2RlJGxvMyIsIl9kZXNjcmliZVBhdGgkbm9kZSRsbzQiLCJvdXRwdXRTb3VyY2UiLCJ0b1NvdXJjZSIsInF1b3RlIiwidHJhaWxpbmdDb21tYSIsInJlc3VsdHNEaXIiLCJqb2luIiwibmV3RmlsZU5hbWUiLCJuZXdGaWxlUGF0aCIsImZzIiwiZXhpc3RzU3luYyIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsIndyaXRlRmlsZVN5bmMiXSwic291cmNlUm9vdCI6IkM6XFxVc2Vyc1xceGFiaWFcXE9uZURyaXZlXFxEb2N1bWVudG9zXFw0Lk1haWxhXFxURkctQmVzdGVsYWtvYWtcXEJlc3RlbGFrb2FrXFwzMF8wNF8yNS0xNV8wNV8yNVxcc3BsaXRJVEpDb2RlU2hpZnRcXCIsInNvdXJjZXMiOlsic3BsaXQtc3BlY3M0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNwbGl0LXNwZWNzLmpzXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuLy8gLS0tIEhlbHBlciBGdW5jdGlvbiAtLS1cclxuY29uc3QgbG9jYXRpb25zQXJlRXF1YWwgPSAobG9jQSwgbG9jQikgPT4ge1xyXG4gICAgaWYgKCFsb2NBIHx8ICFsb2NCKSByZXR1cm4gZmFsc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGxvY0Euc3RhcnQubGluZSA9PT0gbG9jQi5zdGFydC5saW5lICYmXHJcbiAgICAgICAgICAgIGxvY0Euc3RhcnQuY29sdW1uID09PSBsb2NCLnN0YXJ0LmNvbHVtbiAmJlxyXG4gICAgICAgICAgICBsb2NBLmVuZC5saW5lID09PSBsb2NCLmVuZC5saW5lICYmXHJcbiAgICAgICAgICAgIGxvY0EuZW5kLmNvbHVtbiA9PT0gbG9jQi5lbmQuY29sdW1uXHJcbiAgICAgICAgKTtcclxuICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb21wYXJhbmRvIGxvY2FsaXphY2lvbmVzOlwiLCBlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbi8vIC0tLSBGaW4gSGVscGVyIC0tLVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtZXIoZmlsZUluZm8sIGFwaSkge1xyXG4gIGNvbnN0IGogPSBhcGkuanNjb2Rlc2hpZnQ7XHJcbiAgY29uc3Qgcm9vdCA9IGooZmlsZUluZm8uc291cmNlKTtcclxuXHJcbiAgY29uc3QgaXRQYXRocyA9IHJvb3QuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICBjYWxsZWU6IHsgbmFtZTogJ2l0JyB9LFxyXG4gIH0pLnBhdGhzKCk7XHJcblxyXG4gIGlmIChpdFBhdGhzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coYC0+IEFyY2hpdm8gJHtmaWxlSW5mby5wYXRofTogJHtpdFBhdGhzLmxlbmd0aH0gYmxvcXVlKHMpICdpdCcgZW5jb250cmFkb3MuIEdlbmVyYW5kbyBhcmNoaXZvcyBpbmRpdmlkdWFsZXMuLi5gKTtcclxuXHJcbiAgY29uc3Qgb3JpZ2luYWxQYXRoID0gZmlsZUluZm8ucGF0aDtcclxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUob3JpZ2luYWxQYXRoKTtcclxuICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUob3JpZ2luYWxQYXRoKTtcclxuICBjb25zdCBiYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUob3JpZ2luYWxQYXRoLCBleHQpO1xyXG5cclxuICBpdFBhdGhzLmZvckVhY2goKHRhcmdldEl0UGF0aCwgaW5kZXgpID0+IHtcclxuICAgIC8vIDEuIENyZWFyIGNvcGlhIGZyZXNjYSBkZWwgQVNUXHJcbiAgICBjb25zdCBhc3RDb3B5ID0gaihmaWxlSW5mby5zb3VyY2UpO1xyXG5cclxuICAgIC8vIDIuIEVuY29udHJhciB0b2RvcyBsb3MgJ2l0JyBlbiBsYSBjb3BpYVxyXG4gICAgY29uc3QgYWxsSXRQYXRoc0luQ29weSA9IGFzdENvcHkuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICAgICAgY2FsbGVlOiB7IG5hbWU6ICdpdCcgfSxcclxuICAgICAgfSkucGF0aHMoKTtcclxuXHJcbiAgICAvLyAzLiBPYnRlbmVyIGxhIHViaWNhY2nDs24gZGVsICdpdCcgYSBjb25zZXJ2YXJcclxuICAgIGNvbnN0IHRhcmdldExvYyA9IHRhcmdldEl0UGF0aC5ub2RlLmxvYztcclxuICAgIGlmICghdGFyZ2V0TG9jKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgQ3LDrXRpY286IEZhbHRhIGluZm9ybWFjacOzbiBkZSB1YmljYWNpw7NuIHBhcmEgZWwgYmxvcXVlICdpdCcgKMOtbmRpY2UgJHtpbmRleH0pIGVuICR7ZmlsZUluZm8ucGF0aH0uIE5vIHNlIHB1ZWRlIGdlbmVyYXIgYXJjaGl2byAke2luZGV4ICsgMX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDQuIEVsaW1pbmFyIGxvcyAnaXQnIGN1eWEgdWJpY2FjacOzbiBOTyBDT0lOQ0lEQVxyXG4gICAgYWxsSXRQYXRoc0luQ29weS5mb3JFYWNoKGN1cnJlbnRJdFBhdGhJbkNvcHkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRMb2MgPSBjdXJyZW50SXRQYXRoSW5Db3B5Lm5vZGUubG9jO1xyXG4gICAgICAgIGlmICghbG9jYXRpb25zQXJlRXF1YWwoY3VycmVudExvYywgdGFyZ2V0TG9jKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0YXRlbWVudFBhdGggPSBjdXJyZW50SXRQYXRoSW5Db3B5LnBhcmVudFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlbWVudFBhdGgubm9kZS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgJiYgcGFyZW50U3RhdGVtZW50UGF0aC5wYXJlbnRQYXRoPy5ub2RlPy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGoocGFyZW50U3RhdGVtZW50UGF0aCkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgaihjdXJyZW50SXRQYXRoSW5Db3B5KS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBZHZlcnRlbmNpYTogRXN0cnVjdHVyYSBpbmVzcGVyYWRhIHBhcmEgYmxvcXVlICdpdCcgZW4gJHtmaWxlSW5mby5wYXRofSAobMOtbmVhICR7Y3VycmVudExvYz8uc3RhcnQ/LmxpbmV9KS4gUmV2aXNlIGVsIGFyY2hpdm8gJHtpbmRleCArIDF9LmApO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVsaW1pbmFuZG8gYmxvcXVlICdpdCcgKGzDrW5lYSAke2N1cnJlbnRMb2M/LnN0YXJ0Py5saW5lfSkgZW4gJHtmaWxlSW5mby5wYXRofSBwYXJhIGFyY2hpdm8gJHtpbmRleCArIDF9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDUuIC0tLSBOVUVWTyBQQVNPOiBFbGltaW5hciBibG9xdWVzICdkZXNjcmliZScgdmFjw61vcyAtLS1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGVzY3JpYmVQYXRocyA9IGFzdENvcHkuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICAgICAgICAgIGNhbGxlZTogeyBuYW1lOiAnZGVzY3JpYmUnIH1cclxuICAgICAgICB9KS5wYXRocygpO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXIgZW4gUkVWRVJTQSBlcyBpbXBvcnRhbnRlIGFsIGVsaW1pbmFyIG5vZG9zIHBhcmEgbm8gYWZlY3RhciDDrW5kaWNlcy9wYXRoc1xyXG4gICAgICAgIGRlc2NyaWJlUGF0aHMucmV2ZXJzZSgpLmZvckVhY2goZGVzY3JpYmVQYXRoID0+IHtcclxuICAgICAgICAgICAgbGV0IGlzRW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEFjY2VkZXIgYWwgY3VlcnBvIChCbG9ja1N0YXRlbWVudCkgZGUgbGEgZnVuY2nDs24gZGVsIGRlc2NyaWJlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmliZUZ1bmMgPSBkZXNjcmliZVBhdGgubm9kZS5hcmd1bWVudHNbMV07IC8vIEVsIGNhbGxiYWNrIGVzIHVzdWFsbWVudGUgZWwgMsK6IGFyZ3VtZW50b1xyXG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrU3RhdGVtZW50Tm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpYmVGdW5jICYmIChkZXNjcmliZUZ1bmMudHlwZSA9PT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicgfHwgZGVzY3JpYmVGdW5jLnR5cGUgPT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicpICYmIGRlc2NyaWJlRnVuYy5ib2R5LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgYmxvY2tTdGF0ZW1lbnROb2RlID0gZGVzY3JpYmVGdW5jLmJvZHk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAvLyBTaSBsYSBlc3RydWN0dXJhIG5vIGVzIGxhIGVzcGVyYWRhLCBubyBsbyBjb25zaWRlcmFtb3MgdmFjw61vIHBvciBzZWd1cmlkYWRcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBZHZlcnRlbmNpYTogRXN0cnVjdHVyYSBpbmVzcGVyYWRhIGVuIGRlc2NyaWJlIChsw61uZWEgJHtkZXNjcmliZVBhdGgubm9kZS5sb2M/LnN0YXJ0Py5saW5lfSkgZW4gJHtmaWxlSW5mby5wYXRofSBwYXJhIGFyY2hpdm8gJHtpbmRleCArIDF9LiBObyBzZSBsaW1waWFyw6EuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU2FsdGFyIGFsIHNpZ3VpZW50ZSBkZXNjcmliZVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXByb2JhciBzaSBlbCBjdWVycG8gY29udGllbmUgbGxhbWFkYXMgcmVsZXZhbnRlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsZXZhbnRDYWxscyA9IGooYmxvY2tTdGF0ZW1lbnROb2RlKS5maW5kKGouQ2FsbEV4cHJlc3Npb24sIG5vZGUgPT5cclxuICAgICAgICAgICAgICAgICAgICBbJ2l0JywgJ2Rlc2NyaWJlJywgJ2JlZm9yZUVhY2gnLCAnYWZ0ZXJFYWNoJywgJ2JlZm9yZUFsbCcsICdhZnRlckFsbCddLmluY2x1ZGVzKG5vZGUuY2FsbGVlPy5uYW1lKSAvLyBPcHRpb25hbCBjaGFpbmluZyBwb3Igc2kgY2FsbGVlIG5vIGV4aXN0ZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVsZXZhbnRDYWxscy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBoYXkgbGxhbWFkYXMgcmVsZXZhbnRlcywgY29uc2lkZXJhbW9zIGVsIGRlc2NyaWJlIHZhY8Otb1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRW1wdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBjYXRjaCAoZmluZEVycm9yKXtcclxuICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbnNwZWNjaW9uYW5kbyBjdWVycG8gZGUgZGVzY3JpYmUgKGzDrW5lYSAke2Rlc2NyaWJlUGF0aC5ub2RlLmxvYz8uc3RhcnQ/LmxpbmV9KSBlbiAke2ZpbGVJbmZvLnBhdGh9IHBhcmEgYXJjaGl2byAke2luZGV4ICsgMX06YCwgZmluZEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAvLyBObyBlbGltaW5hciBzaSBodWJvIGVycm9yIGFsIGluc3BlY2Npb25hclxyXG4gICAgICAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgLy8gRWxpbWluYXIgZWwgRXhwcmVzc2lvblN0YXRlbWVudCBxdWUgY29udGllbmUgbGEgbGxhbWFkYSBhbCBkZXNjcmliZVxyXG4gICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0YXRlbWVudFBhdGggPSBkZXNjcmliZVBhdGgucGFyZW50UGF0aDtcclxuICAgICAgICAgICAgICAgICBpZiAocGFyZW50U3RhdGVtZW50UGF0aC5ub2RlLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICBqKHBhcmVudFN0YXRlbWVudFBhdGgpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgLSBEZXNjcmliZSB2YWPDrW8gZWxpbWluYWRvIChsw61uZWEgJHtkZXNjcmliZVBhdGgubm9kZS5sb2M/LnN0YXJ0Py5saW5lfSkgZW4gYXJjaGl2byAke2luZGV4ICsgMX1gKTtcclxuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFkdmVydGVuY2lhOiBEZXNjcmliZSB2YWPDrW8gKGzDrW5lYSAke2Rlc2NyaWJlUGF0aC5ub2RlLmxvYz8uc3RhcnQ/LmxpbmV9KSBubyBlc3RhYmEgZW4gdW4gRXhwcmVzc2lvblN0YXRlbWVudCBkaXJlY3RvLiBObyBzZSBlbGltaW7Dsy5gKTtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZHVyYW50ZSBsYSBsaW1waWV6YSBkZSBibG9xdWVzIGRlc2NyaWJlIGVuICR7ZmlsZUluZm8ucGF0aH0gcGFyYSBhcmNoaXZvICR7aW5kZXggKyAxfTpgLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0gRklOIE5VRVZPIFBBU08gLS0tXHJcblxyXG5cclxuICAgIC8vIDYuIEdlbmVyYXIgY8OzZGlnbyBmdWVudGUgZGVzZGUgZWwgQVNUIG1vZGlmaWNhZG8gKGFob3JhIHRhbWJpw6luIHNpbiBkZXNjcmliZXMgdmFjw61vcylcclxuICAgIGNvbnN0IG91dHB1dFNvdXJjZSA9IGFzdENvcHkudG9Tb3VyY2UoeyBxdW90ZTogJ3NpbmdsZScsIHRyYWlsaW5nQ29tbWE6IHRydWUgfSk7XHJcblxyXG4gICAgLy8gNy4gQ29uc3RydWlyIG51ZXZvIG5vbWJyZSBkZSBhcmNoaXZvIHkgcnV0YSBkZSBkaXJlY3RvcmlvIGRlIHJlc3VsdGFkb3NcclxuICAgIGNvbnN0IHJlc3VsdHNEaXIgPSBwYXRoLmpvaW4oZGlyLCAncmVzdWx0cycpOyAvLyBEaXJlY3RvcmlvIGRlIHJlc3VsdGFkb3NcclxuICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gYCR7YmFzZU5hbWV9JHtpbmRleCArIDF9JHtleHR9YDtcclxuICAgIGNvbnN0IG5ld0ZpbGVQYXRoID0gcGF0aC5qb2luKHJlc3VsdHNEaXIsIG5ld0ZpbGVOYW1lKTsgLy8gUnV0YSBjb21wbGV0YSBlbiAncmVzdWx0cydcclxuXHJcbiAgICAvLyA4LiBBc2VndXJhcnNlIGRlIHF1ZSBlbCBkaXJlY3RvcmlvICdyZXN1bHRzJyBleGlzdGFcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHJlc3VsdHNEaXIpKSB7XHJcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhyZXN1bHRzRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIERpcmVjdG9yaW8gJ3Jlc3VsdHMnIGNyZWFkbyBlbjogJHtyZXN1bHRzRGlyfWApO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYW5kbyBkaXJlY3RvcmlvICR7cmVzdWx0c0Rpcn06YCwgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjsgLy8gTm8gY29udGludWFyIHNpIG5vIHNlIHB1ZWRlIGNyZWFyIGVsIGRpcmVjdG9yaW9cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gOS4gRXNjcmliaXIgZWwgbnVldm8gYXJjaGl2byBlbiBlbCBkaXJlY3RvcmlvICdyZXN1bHRzJ1xyXG4gICAgdHJ5IHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyhuZXdGaWxlUGF0aCwgb3V0cHV0U291cmNlKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIENyZWFkbzogJHtuZXdGaWxlUGF0aH1gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVzY3JpYmllbmRvIGFyY2hpdm8gJHtuZXdGaWxlUGF0aH06YCwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBEZXZvbHZlciB1bmRlZmluZWQvbnVsbCBwYXJhIG5vIG1vZGlmaWNhciBlbCBvcmlnaW5hbFxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8vIGV4cG9ydCBjb25zdCBwYXJzZXIgPSAndHMnOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsSUFBQUEsR0FBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsS0FBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBQXdCLFNBQUFELHVCQUFBRyxDQUFBLFdBQUFBLENBQUEsSUFBQUEsQ0FBQSxDQUFBQyxVQUFBLEdBQUFELENBQUEsS0FBQUUsT0FBQSxFQUFBRixDQUFBO0FBRnhCOztBQUlBO0FBQ0EsTUFBTUcsaUJBQWlCLEdBQUdBLENBQUNDLElBQUksRUFBRUMsSUFBSSxLQUFLO0VBQ3RDLElBQUksQ0FBQ0QsSUFBSSxJQUFJLENBQUNDLElBQUksRUFBRSxPQUFPLEtBQUs7RUFDaEMsSUFBSTtJQUNBLE9BQ0lELElBQUksQ0FBQ0UsS0FBSyxDQUFDQyxJQUFJLEtBQUtGLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLElBQ25DSCxJQUFJLENBQUNFLEtBQUssQ0FBQ0UsTUFBTSxLQUFLSCxJQUFJLENBQUNDLEtBQUssQ0FBQ0UsTUFBTSxJQUN2Q0osSUFBSSxDQUFDSyxHQUFHLENBQUNGLElBQUksS0FBS0YsSUFBSSxDQUFDSSxHQUFHLENBQUNGLElBQUksSUFDL0JILElBQUksQ0FBQ0ssR0FBRyxDQUFDRCxNQUFNLEtBQUtILElBQUksQ0FBQ0ksR0FBRyxDQUFDRCxNQUFNO0VBRTNDLENBQUMsQ0FBQyxPQUFNUixDQUFDLEVBQUU7SUFDUFUsT0FBTyxDQUFDQyxLQUFLLENBQUMsa0NBQWtDLEVBQUVYLENBQUMsQ0FBQztJQUNwRCxPQUFPLEtBQUs7RUFDaEI7QUFDSixDQUFDO0FBQ0Q7O0FBRWUsU0FBU1ksV0FBV0EsQ0FBQ0MsUUFBUSxFQUFFQyxHQUFHLEVBQUU7RUFDakQsTUFBTUMsQ0FBQyxHQUFHRCxHQUFHLENBQUNFLFdBQVc7RUFDekIsTUFBTUMsSUFBSSxHQUFHRixDQUFDLENBQUNGLFFBQVEsQ0FBQ0ssTUFBTSxDQUFDO0VBRS9CLE1BQU1DLE9BQU8sR0FBR0YsSUFBSSxDQUFDRyxJQUFJLENBQUNMLENBQUMsQ0FBQ00sY0FBYyxFQUFFO0lBQzFDQyxNQUFNLEVBQUU7TUFBRUMsSUFBSSxFQUFFO0lBQUs7RUFDdkIsQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQyxDQUFDO0VBRVYsSUFBSUwsT0FBTyxDQUFDTSxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQ3ZCLE9BQU9DLFNBQVM7RUFDbEI7RUFFQWhCLE9BQU8sQ0FBQ2lCLEdBQUcsQ0FBQyxjQUFjZCxRQUFRLENBQUNlLElBQUksS0FBS1QsT0FBTyxDQUFDTSxNQUFNLGlFQUFpRSxDQUFDO0VBRTVILE1BQU1JLFlBQVksR0FBR2hCLFFBQVEsQ0FBQ2UsSUFBSTtFQUNsQyxNQUFNRSxHQUFHLEdBQUdGLGFBQUksQ0FBQ0csT0FBTyxDQUFDRixZQUFZLENBQUM7RUFDdEMsTUFBTUcsR0FBRyxHQUFHSixhQUFJLENBQUNLLE9BQU8sQ0FBQ0osWUFBWSxDQUFDO0VBQ3RDLE1BQU1LLFFBQVEsR0FBR04sYUFBSSxDQUFDTyxRQUFRLENBQUNOLFlBQVksRUFBRUcsR0FBRyxDQUFDO0VBRWpEYixPQUFPLENBQUNpQixPQUFPLENBQUMsQ0FBQ0MsWUFBWSxFQUFFQyxLQUFLLEtBQUs7SUFDdkM7SUFDQSxNQUFNQyxPQUFPLEdBQUd4QixDQUFDLENBQUNGLFFBQVEsQ0FBQ0ssTUFBTSxDQUFDOztJQUVsQztJQUNBLE1BQU1zQixnQkFBZ0IsR0FBR0QsT0FBTyxDQUFDbkIsSUFBSSxDQUFDTCxDQUFDLENBQUNNLGNBQWMsRUFBRTtNQUNwREMsTUFBTSxFQUFFO1FBQUVDLElBQUksRUFBRTtNQUFLO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDQyxLQUFLLENBQUMsQ0FBQzs7SUFFWjtJQUNBLE1BQU1pQixTQUFTLEdBQUdKLFlBQVksQ0FBQ0ssSUFBSSxDQUFDQyxHQUFHO0lBQ3ZDLElBQUksQ0FBQ0YsU0FBUyxFQUFFO01BQ1ovQixPQUFPLENBQUNDLEtBQUssQ0FBQyw2RUFBNkUyQixLQUFLLFFBQVF6QixRQUFRLENBQUNlLElBQUksaUNBQWlDVSxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUM7TUFDbks7SUFDSjs7SUFFQTtJQUNBRSxnQkFBZ0IsQ0FBQ0osT0FBTyxDQUFDUSxtQkFBbUIsSUFBSTtNQUM1QyxNQUFNQyxVQUFVLEdBQUdELG1CQUFtQixDQUFDRixJQUFJLENBQUNDLEdBQUc7TUFDL0MsSUFBSSxDQUFDeEMsaUJBQWlCLENBQUMwQyxVQUFVLEVBQUVKLFNBQVMsQ0FBQyxFQUFFO1FBQzNDLElBQUk7VUFBQSxJQUFBSyxxQkFBQTtVQUNDLE1BQU1DLG1CQUFtQixHQUFHSCxtQkFBbUIsQ0FBQ0ksVUFBVTtVQUMxRCxJQUFJRCxtQkFBbUIsQ0FBQ0wsSUFBSSxDQUFDTyxJQUFJLEtBQUsscUJBQXFCLEtBQUFILHFCQUFBLEdBQUlDLG1CQUFtQixDQUFDQyxVQUFVLGNBQUFGLHFCQUFBLGdCQUFBQSxxQkFBQSxHQUE5QkEscUJBQUEsQ0FBZ0NKLElBQUksY0FBQUkscUJBQUEsZUFBcENBLHFCQUFBLENBQXNDRyxJQUFJLEVBQUU7WUFDdkdsQyxDQUFDLENBQUNnQyxtQkFBbUIsQ0FBQyxDQUFDRyxNQUFNLENBQUMsQ0FBQztVQUNuQyxDQUFDLE1BQU07WUFBQSxJQUFBQyxpQkFBQTtZQUNIcEMsQ0FBQyxDQUFDNkIsbUJBQW1CLENBQUMsQ0FBQ00sTUFBTSxDQUFDLENBQUM7WUFDL0J4QyxPQUFPLENBQUMwQyxJQUFJLENBQUMsMERBQTBEdkMsUUFBUSxDQUFDZSxJQUFJLFdBQVdpQixVQUFVLGFBQVZBLFVBQVUsZ0JBQUFNLGlCQUFBLEdBQVZOLFVBQVUsQ0FBRXZDLEtBQUssY0FBQTZDLGlCQUFBLHVCQUFqQkEsaUJBQUEsQ0FBbUI1QyxJQUFJLHdCQUF3QitCLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQztVQUMvSjtRQUNMLENBQUMsQ0FBQyxPQUFPM0IsS0FBSyxFQUFFO1VBQUEsSUFBQTBDLGtCQUFBO1VBQ1ozQyxPQUFPLENBQUNDLEtBQUssQ0FBQyx1Q0FBdUNrQyxVQUFVLGFBQVZBLFVBQVUsZ0JBQUFRLGtCQUFBLEdBQVZSLFVBQVUsQ0FBRXZDLEtBQUssY0FBQStDLGtCQUFBLHVCQUFqQkEsa0JBQUEsQ0FBbUI5QyxJQUFJLFFBQVFNLFFBQVEsQ0FBQ2UsSUFBSSxpQkFBaUJVLEtBQUssR0FBRyxDQUFDLEdBQUcsRUFBRTNCLEtBQUssQ0FBQztRQUMxSTtNQUNKO0lBQ0osQ0FBQyxDQUFDOztJQUVGO0lBQ0EsSUFBSTtNQUNBLE1BQU0yQyxhQUFhLEdBQUdmLE9BQU8sQ0FBQ25CLElBQUksQ0FBQ0wsQ0FBQyxDQUFDTSxjQUFjLEVBQUU7UUFDakRDLE1BQU0sRUFBRTtVQUFFQyxJQUFJLEVBQUU7UUFBVztNQUMvQixDQUFDLENBQUMsQ0FBQ0MsS0FBSyxDQUFDLENBQUM7O01BRVY7TUFDQThCLGFBQWEsQ0FBQ0MsT0FBTyxDQUFDLENBQUMsQ0FBQ25CLE9BQU8sQ0FBQ29CLFlBQVksSUFBSTtRQUM1QyxJQUFJQyxPQUFPLEdBQUcsS0FBSztRQUNuQixJQUFJO1VBQ0E7VUFDQSxNQUFNQyxZQUFZLEdBQUdGLFlBQVksQ0FBQ2QsSUFBSSxDQUFDaUIsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDckQsSUFBSUMsa0JBQWtCO1VBRXRCLElBQUlGLFlBQVksS0FBS0EsWUFBWSxDQUFDVCxJQUFJLEtBQUssb0JBQW9CLElBQUlTLFlBQVksQ0FBQ1QsSUFBSSxLQUFLLHlCQUF5QixDQUFDLElBQUlTLFlBQVksQ0FBQ0csSUFBSSxDQUFDWixJQUFJLEtBQUssZ0JBQWdCLEVBQUU7WUFDL0pXLGtCQUFrQixHQUFHRixZQUFZLENBQUNHLElBQUk7VUFDM0MsQ0FBQyxNQUFNO1lBQUEsSUFBQUMscUJBQUE7WUFDRjtZQUNBcEQsT0FBTyxDQUFDMEMsSUFBSSxDQUFDLDBEQUFBVSxxQkFBQSxHQUF5RE4sWUFBWSxDQUFDZCxJQUFJLENBQUNDLEdBQUcsY0FBQW1CLHFCQUFBLGdCQUFBQSxxQkFBQSxHQUFyQkEscUJBQUEsQ0FBdUJ4RCxLQUFLLGNBQUF3RCxxQkFBQSx1QkFBNUJBLHFCQUFBLENBQThCdkQsSUFBSSxRQUFRTSxRQUFRLENBQUNlLElBQUksaUJBQWlCVSxLQUFLLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQztZQUMzSyxPQUFPLENBQUM7VUFDYjs7VUFFQTtVQUNBLE1BQU15QixhQUFhLEdBQUdoRCxDQUFDLENBQUM2QyxrQkFBa0IsQ0FBQyxDQUFDeEMsSUFBSSxDQUFDTCxDQUFDLENBQUNNLGNBQWMsRUFBRXFCLElBQUk7WUFBQSxJQUFBc0IsWUFBQTtZQUFBLE9BQ25FLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQ0MsUUFBUSxFQUFBRCxZQUFBLEdBQUN0QixJQUFJLENBQUNwQixNQUFNLGNBQUEwQyxZQUFBLHVCQUFYQSxZQUFBLENBQWF6QyxJQUFJLENBQUM7VUFBQSxFQUFDO1VBQ3ZHLENBQUM7VUFFRCxJQUFJd0MsYUFBYSxDQUFDdEMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM1QjtZQUNBZ0MsT0FBTyxHQUFHLElBQUk7VUFDbEI7UUFFSixDQUFDLENBQUMsT0FBT1MsU0FBUyxFQUFDO1VBQUEsSUFBQUMsc0JBQUE7VUFDZHpELE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLG1EQUFBd0Qsc0JBQUEsR0FBa0RYLFlBQVksQ0FBQ2QsSUFBSSxDQUFDQyxHQUFHLGNBQUF3QixzQkFBQSxnQkFBQUEsc0JBQUEsR0FBckJBLHNCQUFBLENBQXVCN0QsS0FBSyxjQUFBNkQsc0JBQUEsdUJBQTVCQSxzQkFBQSxDQUE4QjVELElBQUksUUFBUU0sUUFBUSxDQUFDZSxJQUFJLGlCQUFpQlUsS0FBSyxHQUFHLENBQUMsR0FBRyxFQUFFNEIsU0FBUyxDQUFDO1VBQ2hLO1VBQ0FULE9BQU8sR0FBRyxLQUFLO1FBQ3BCO1FBR0EsSUFBSUEsT0FBTyxFQUFFO1VBQ1I7VUFDQSxNQUFNVixtQkFBbUIsR0FBR1MsWUFBWSxDQUFDUixVQUFVO1VBQ25ELElBQUlELG1CQUFtQixDQUFDTCxJQUFJLENBQUNPLElBQUksS0FBSyxxQkFBcUIsRUFBRTtZQUFBLElBQUFtQixzQkFBQTtZQUN6RHJELENBQUMsQ0FBQ2dDLG1CQUFtQixDQUFDLENBQUNHLE1BQU0sQ0FBQyxDQUFDO1lBQy9CeEMsT0FBTyxDQUFDaUIsR0FBRyxDQUFDLHlDQUFBeUMsc0JBQUEsR0FBd0NaLFlBQVksQ0FBQ2QsSUFBSSxDQUFDQyxHQUFHLGNBQUF5QixzQkFBQSxnQkFBQUEsc0JBQUEsR0FBckJBLHNCQUFBLENBQXVCOUQsS0FBSyxjQUFBOEQsc0JBQUEsdUJBQTVCQSxzQkFBQSxDQUE4QjdELElBQUksZ0JBQWdCK0IsS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDO1VBQ3RILENBQUMsTUFBTTtZQUFBLElBQUErQixzQkFBQTtZQUNIM0QsT0FBTyxDQUFDMEMsSUFBSSxDQUFDLHVDQUFBaUIsc0JBQUEsR0FBc0NiLFlBQVksQ0FBQ2QsSUFBSSxDQUFDQyxHQUFHLGNBQUEwQixzQkFBQSxnQkFBQUEsc0JBQUEsR0FBckJBLHNCQUFBLENBQXVCL0QsS0FBSyxjQUFBK0Qsc0JBQUEsdUJBQTVCQSxzQkFBQSxDQUE4QjlELElBQUksK0RBQStELENBQUM7VUFDeko7UUFDTDtNQUNKLENBQUMsQ0FBQztJQUNOLENBQUMsQ0FBQyxPQUFPSSxLQUFLLEVBQUU7TUFDWkQsT0FBTyxDQUFDQyxLQUFLLENBQUMsb0RBQW9ERSxRQUFRLENBQUNlLElBQUksaUJBQWlCVSxLQUFLLEdBQUcsQ0FBQyxHQUFHLEVBQUUzQixLQUFLLENBQUM7SUFDeEg7SUFDQTs7SUFHQTtJQUNBLE1BQU0yRCxZQUFZLEdBQUcvQixPQUFPLENBQUNnQyxRQUFRLENBQUM7TUFBRUMsS0FBSyxFQUFFLFFBQVE7TUFBRUMsYUFBYSxFQUFFO0lBQUssQ0FBQyxDQUFDOztJQUUvRTtJQUNBLE1BQU1DLFVBQVUsR0FBRzlDLGFBQUksQ0FBQytDLElBQUksQ0FBQzdDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQzlDLE1BQU04QyxXQUFXLEdBQUcsR0FBRzFDLFFBQVEsR0FBR0ksS0FBSyxHQUFHLENBQUMsR0FBR04sR0FBRyxFQUFFO0lBQ25ELE1BQU02QyxXQUFXLEdBQUdqRCxhQUFJLENBQUMrQyxJQUFJLENBQUNELFVBQVUsRUFBRUUsV0FBVyxDQUFDLENBQUMsQ0FBQzs7SUFFeEQ7SUFDQSxJQUFJO01BQ0EsSUFBSSxDQUFDRSxXQUFFLENBQUNDLFVBQVUsQ0FBQ0wsVUFBVSxDQUFDLEVBQUU7UUFDNUJJLFdBQUUsQ0FBQ0UsU0FBUyxDQUFDTixVQUFVLEVBQUU7VUFBRU8sU0FBUyxFQUFFO1FBQUssQ0FBQyxDQUFDO1FBQzdDdkUsT0FBTyxDQUFDaUIsR0FBRyxDQUFDLHNDQUFzQytDLFVBQVUsRUFBRSxDQUFDO01BQ25FO0lBQ0osQ0FBQyxDQUFDLE9BQU8vRCxLQUFLLEVBQUU7TUFDWkQsT0FBTyxDQUFDQyxLQUFLLENBQUMsNEJBQTRCK0QsVUFBVSxHQUFHLEVBQUUvRCxLQUFLLENBQUM7TUFDL0QsT0FBTyxDQUFDO0lBQ1o7O0lBR0E7SUFDQSxJQUFJO01BQ0ZtRSxXQUFFLENBQUNJLGFBQWEsQ0FBQ0wsV0FBVyxFQUFFUCxZQUFZLENBQUM7TUFDM0M1RCxPQUFPLENBQUNpQixHQUFHLENBQUMsY0FBY2tELFdBQVcsRUFBRSxDQUFDO0lBQzFDLENBQUMsQ0FBQyxPQUFPbEUsS0FBSyxFQUFFO01BQ2RELE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLDZCQUE2QmtFLFdBQVcsR0FBRyxFQUFFbEUsS0FBSyxDQUFDO0lBQ25FO0VBQ0YsQ0FBQyxDQUFDOztFQUVGO0VBQ0EsT0FBT2UsU0FBUztBQUNsQjs7QUFFQSIsImlnbm9yZUxpc3QiOltdfQ==","map":{"version":3,"names":["_fs","_interopRequireDefault","require","_path","e","__esModule","default","locationsAreEqual","locA","locB","start","line","column","end","console","error","transformer","fileInfo","api","j","jscodeshift","root","source","itPaths","find","CallExpression","callee","name","paths","length","undefined","log","path","originalPath","dir","dirname","ext","extname","baseName","basename","forEach","targetItPath","index","astCopy","allItPathsInCopy","targetLoc","node","loc","currentItPathInCopy","currentLoc","_parentStatementPath$","parentStatementPath","parentPath","type","remove","_currentLoc$start","warn","_currentLoc$start2","describePaths","reverse","describePath","isEmpty","describeFunc","arguments","blockStatementNode","body","_describePath$node$lo","relevantCalls","_node$callee","includes","findError","_describePath$node$lo2","_describePath$node$lo3","_describePath$node$lo4","outputSource","toSource","quote","trailingComma","resultsDir","join","newFileName","newFilePath","fs","existsSync","mkdirSync","recursive","writeFileSync"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\30_04_25-15_05_25\\splitITJCodeShift\\","sources":["split-specs4.js"],"sourcesContent":["// split-specs.js\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\n// --- Helper Function ---\r\nconst locationsAreEqual = (locA, locB) => {\r\n    if (!locA || !locB) return false;\r\n    try {\r\n        return (\r\n            locA.start.line === locB.start.line &&\r\n            locA.start.column === locB.start.column &&\r\n            locA.end.line === locB.end.line &&\r\n            locA.end.column === locB.end.column\r\n        );\r\n    } catch(e) {\r\n        console.error(\"Error comparando localizaciones:\", e);\r\n        return false;\r\n    }\r\n};\r\n// --- Fin Helper ---\r\n\r\nexport default function transformer(fileInfo, api) {\r\n  const j = api.jscodeshift;\r\n  const root = j(fileInfo.source);\r\n\r\n  const itPaths = root.find(j.CallExpression, {\r\n    callee: { name: 'it' },\r\n  }).paths();\r\n\r\n  if (itPaths.length <= 1) {\r\n    return undefined;\r\n  }\r\n\r\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\r\n\r\n  const originalPath = fileInfo.path;\r\n  const dir = path.dirname(originalPath);\r\n  const ext = path.extname(originalPath);\r\n  const baseName = path.basename(originalPath, ext);\r\n\r\n  itPaths.forEach((targetItPath, index) => {\r\n    // 1. Crear copia fresca del AST\r\n    const astCopy = j(fileInfo.source);\r\n\r\n    // 2. Encontrar todos los 'it' en la copia\r\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\r\n        callee: { name: 'it' },\r\n      }).paths();\r\n\r\n    // 3. Obtener la ubicación del 'it' a conservar\r\n    const targetLoc = targetItPath.node.loc;\r\n    if (!targetLoc) {\r\n        console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\r\n        return;\r\n    }\r\n\r\n    // 4. Eliminar los 'it' cuya ubicación NO COINCIDA\r\n    allItPathsInCopy.forEach(currentItPathInCopy => {\r\n        const currentLoc = currentItPathInCopy.node.loc;\r\n        if (!locationsAreEqual(currentLoc, targetLoc)) {\r\n            try {\r\n                 const parentStatementPath = currentItPathInCopy.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement' && parentStatementPath.parentPath?.node?.type) {\r\n                     j(parentStatementPath).remove();\r\n                 } else {\r\n                     j(currentItPathInCopy).remove();\r\n                     console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc?.start?.line}). Revise el archivo ${index + 1}.`);\r\n                 }\r\n            } catch (error) {\r\n                console.error(`Error eliminando bloque 'it' (línea ${currentLoc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n            }\r\n        }\r\n    });\r\n\r\n    // 5. --- NUEVO PASO: Eliminar bloques 'describe' vacíos ---\r\n    try {\r\n        const describePaths = astCopy.find(j.CallExpression, {\r\n            callee: { name: 'describe' }\r\n        }).paths();\r\n\r\n        // Iterar en REVERSA es importante al eliminar nodos para no afectar índices/paths\r\n        describePaths.reverse().forEach(describePath => {\r\n            let isEmpty = false;\r\n            try {\r\n                // Acceder al cuerpo (BlockStatement) de la función del describe\r\n                const describeFunc = describePath.node.arguments[1]; // El callback es usualmente el 2º argumento\r\n                let blockStatementNode;\r\n\r\n                if (describeFunc && (describeFunc.type === 'FunctionExpression' || describeFunc.type === 'ArrowFunctionExpression') && describeFunc.body.type === 'BlockStatement') {\r\n                     blockStatementNode = describeFunc.body;\r\n                } else {\r\n                     // Si la estructura no es la esperada, no lo consideramos vacío por seguridad\r\n                     console.warn(`Advertencia: Estructura inesperada en describe (línea ${describePath.node.loc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}. No se limpiará.`);\r\n                     return; // Saltar al siguiente describe\r\n                }\r\n\r\n                // Comprobar si el cuerpo contiene llamadas relevantes\r\n                const relevantCalls = j(blockStatementNode).find(j.CallExpression, node =>\r\n                    ['it', 'describe', 'beforeEach', 'afterEach', 'beforeAll', 'afterAll'].includes(node.callee?.name) // Optional chaining por si callee no existe\r\n                );\r\n\r\n                if (relevantCalls.length === 0) {\r\n                    // No hay llamadas relevantes, consideramos el describe vacío\r\n                    isEmpty = true;\r\n                }\r\n\r\n            } catch (findError){\r\n                 console.error(`Error inspeccionando cuerpo de describe (línea ${describePath.node.loc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, findError);\r\n                 // No eliminar si hubo error al inspeccionar\r\n                 isEmpty = false;\r\n            }\r\n\r\n\r\n            if (isEmpty) {\r\n                 // Eliminar el ExpressionStatement que contiene la llamada al describe\r\n                 const parentStatementPath = describePath.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement') {\r\n                     j(parentStatementPath).remove();\r\n                     console.log(`   - Describe vacío eliminado (línea ${describePath.node.loc?.start?.line}) en archivo ${index + 1}`);\r\n                 } else {\r\n                     console.warn(`Advertencia: Describe vacío (línea ${describePath.node.loc?.start?.line}) no estaba en un ExpressionStatement directo. No se eliminó.`);\r\n                 }\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error(`Error durante la limpieza de bloques describe en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n    }\r\n    // --- FIN NUEVO PASO ---\r\n\r\n\r\n    // 6. Generar código fuente desde el AST modificado (ahora también sin describes vacíos)\r\n    const outputSource = astCopy.toSource({ quote: 'single', trailingComma: true });\r\n\r\n    // 7. Construir nuevo nombre de archivo y ruta de directorio de resultados\r\n    const resultsDir = path.join(dir, 'results'); // Directorio de resultados\r\n    const newFileName = `${baseName}${index + 1}${ext}`;\r\n    const newFilePath = path.join(resultsDir, newFileName); // Ruta completa en 'results'\r\n\r\n    // 8. Asegurarse de que el directorio 'results' exista\r\n    try {\r\n        if (!fs.existsSync(resultsDir)) {\r\n            fs.mkdirSync(resultsDir, { recursive: true });\r\n            console.log(`   Directorio 'results' creado en: ${resultsDir}`);\r\n        }\r\n    } catch (error) {\r\n        console.error(`Error creando directorio ${resultsDir}:`, error);\r\n        return; // No continuar si no se puede crear el directorio\r\n    }\r\n\r\n\r\n    // 9. Escribir el nuevo archivo en el directorio 'results'\r\n    try {\r\n      fs.writeFileSync(newFilePath, outputSource);\r\n      console.log(`   Creado: ${newFilePath}`);\r\n    } catch (error) {\r\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\r\n    }\r\n  });\r\n\r\n  // Devolver undefined/null para no modificar el original\r\n  return undefined;\r\n}\r\n\r\n// export const parser = 'ts';"],"mappings":";;;;;;AACA,IAAAA,GAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,KAAA,GAAAF,sBAAA,CAAAC,OAAA;AAAwB,SAAAD,uBAAAG,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAFxB;;AAIA;AACA,MAAMG,iBAAiB,GAAGA,CAACC,IAAI,EAAEC,IAAI,KAAK;EACtC,IAAI,CAACD,IAAI,IAAI,CAACC,IAAI,EAAE,OAAO,KAAK;EAChC,IAAI;IACA,OACID,IAAI,CAACE,KAAK,CAACC,IAAI,KAAKF,IAAI,CAACC,KAAK,CAACC,IAAI,IACnCH,IAAI,CAACE,KAAK,CAACE,MAAM,KAAKH,IAAI,CAACC,KAAK,CAACE,MAAM,IACvCJ,IAAI,CAACK,GAAG,CAACF,IAAI,KAAKF,IAAI,CAACI,GAAG,CAACF,IAAI,IAC/BH,IAAI,CAACK,GAAG,CAACD,MAAM,KAAKH,IAAI,CAACI,GAAG,CAACD,MAAM;EAE3C,CAAC,CAAC,OAAMR,CAAC,EAAE;IACPU,OAAO,CAACC,KAAK,CAAC,kCAAkC,EAAEX,CAAC,CAAC;IACpD,OAAO,KAAK;EAChB;AACJ,CAAC;AACD;;AAEe,SAASY,WAAWA,CAACC,QAAQ,EAAEC,GAAG,EAAE;EACjD,MAAMC,CAAC,GAAGD,GAAG,CAACE,WAAW;EACzB,MAAMC,IAAI,GAAGF,CAAC,CAACF,QAAQ,CAACK,MAAM,CAAC;EAE/B,MAAMC,OAAO,GAAGF,IAAI,CAACG,IAAI,CAACL,CAAC,CAACM,cAAc,EAAE;IAC1CC,MAAM,EAAE;MAAEC,IAAI,EAAE;IAAK;EACvB,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC;EAEV,IAAIL,OAAO,CAACM,MAAM,IAAI,CAAC,EAAE;IACvB,OAAOC,SAAS;EAClB;EAEAhB,OAAO,CAACiB,GAAG,CAAC,cAAcd,QAAQ,CAACe,IAAI,KAAKT,OAAO,CAACM,MAAM,iEAAiE,CAAC;EAE5H,MAAMI,YAAY,GAAGhB,QAAQ,CAACe,IAAI;EAClC,MAAME,GAAG,GAAGF,aAAI,CAACG,OAAO,CAACF,YAAY,CAAC;EACtC,MAAMG,GAAG,GAAGJ,aAAI,CAACK,OAAO,CAACJ,YAAY,CAAC;EACtC,MAAMK,QAAQ,GAAGN,aAAI,CAACO,QAAQ,CAACN,YAAY,EAAEG,GAAG,CAAC;EAEjDb,OAAO,CAACiB,OAAO,CAAC,CAACC,YAAY,EAAEC,KAAK,KAAK;IACvC;IACA,MAAMC,OAAO,GAAGxB,CAAC,CAACF,QAAQ,CAACK,MAAM,CAAC;;IAElC;IACA,MAAMsB,gBAAgB,GAAGD,OAAO,CAACnB,IAAI,CAACL,CAAC,CAACM,cAAc,EAAE;MACpDC,MAAM,EAAE;QAAEC,IAAI,EAAE;MAAK;IACvB,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC;;IAEZ;IACA,MAAMiB,SAAS,GAAGJ,YAAY,CAACK,IAAI,CAACC,GAAG;IACvC,IAAI,CAACF,SAAS,EAAE;MACZ/B,OAAO,CAACC,KAAK,CAAC,6EAA6E2B,KAAK,QAAQzB,QAAQ,CAACe,IAAI,iCAAiCU,KAAK,GAAG,CAAC,GAAG,CAAC;MACnK;IACJ;;IAEA;IACAE,gBAAgB,CAACJ,OAAO,CAACQ,mBAAmB,IAAI;MAC5C,MAAMC,UAAU,GAAGD,mBAAmB,CAACF,IAAI,CAACC,GAAG;MAC/C,IAAI,CAACxC,iBAAiB,CAAC0C,UAAU,EAAEJ,SAAS,CAAC,EAAE;QAC3C,IAAI;UAAA,IAAAK,qBAAA;UACC,MAAMC,mBAAmB,GAAGH,mBAAmB,CAACI,UAAU;UAC1D,IAAID,mBAAmB,CAACL,IAAI,CAACO,IAAI,KAAK,qBAAqB,KAAAH,qBAAA,GAAIC,mBAAmB,CAACC,UAAU,cAAAF,qBAAA,gBAAAA,qBAAA,GAA9BA,qBAAA,CAAgCJ,IAAI,cAAAI,qBAAA,eAApCA,qBAAA,CAAsCG,IAAI,EAAE;YACvGlC,CAAC,CAACgC,mBAAmB,CAAC,CAACG,MAAM,CAAC,CAAC;UACnC,CAAC,MAAM;YAAA,IAAAC,iBAAA;YACHpC,CAAC,CAAC6B,mBAAmB,CAAC,CAACM,MAAM,CAAC,CAAC;YAC/BxC,OAAO,CAAC0C,IAAI,CAAC,0DAA0DvC,QAAQ,CAACe,IAAI,WAAWiB,UAAU,aAAVA,UAAU,gBAAAM,iBAAA,GAAVN,UAAU,CAAEvC,KAAK,cAAA6C,iBAAA,uBAAjBA,iBAAA,CAAmB5C,IAAI,wBAAwB+B,KAAK,GAAG,CAAC,GAAG,CAAC;UAC/J;QACL,CAAC,CAAC,OAAO3B,KAAK,EAAE;UAAA,IAAA0C,kBAAA;UACZ3C,OAAO,CAACC,KAAK,CAAC,uCAAuCkC,UAAU,aAAVA,UAAU,gBAAAQ,kBAAA,GAAVR,UAAU,CAAEvC,KAAK,cAAA+C,kBAAA,uBAAjBA,kBAAA,CAAmB9C,IAAI,QAAQM,QAAQ,CAACe,IAAI,iBAAiBU,KAAK,GAAG,CAAC,GAAG,EAAE3B,KAAK,CAAC;QAC1I;MACJ;IACJ,CAAC,CAAC;;IAEF;IACA,IAAI;MACA,MAAM2C,aAAa,GAAGf,OAAO,CAACnB,IAAI,CAACL,CAAC,CAACM,cAAc,EAAE;QACjDC,MAAM,EAAE;UAAEC,IAAI,EAAE;QAAW;MAC/B,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC;;MAEV;MACA8B,aAAa,CAACC,OAAO,CAAC,CAAC,CAACnB,OAAO,CAACoB,YAAY,IAAI;QAC5C,IAAIC,OAAO,GAAG,KAAK;QACnB,IAAI;UACA;UACA,MAAMC,YAAY,GAAGF,YAAY,CAACd,IAAI,CAACiB,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;UACrD,IAAIC,kBAAkB;UAEtB,IAAIF,YAAY,KAAKA,YAAY,CAACT,IAAI,KAAK,oBAAoB,IAAIS,YAAY,CAACT,IAAI,KAAK,yBAAyB,CAAC,IAAIS,YAAY,CAACG,IAAI,CAACZ,IAAI,KAAK,gBAAgB,EAAE;YAC/JW,kBAAkB,GAAGF,YAAY,CAACG,IAAI;UAC3C,CAAC,MAAM;YAAA,IAAAC,qBAAA;YACF;YACApD,OAAO,CAAC0C,IAAI,CAAC,0DAAAU,qBAAA,GAAyDN,YAAY,CAACd,IAAI,CAACC,GAAG,cAAAmB,qBAAA,gBAAAA,qBAAA,GAArBA,qBAAA,CAAuBxD,KAAK,cAAAwD,qBAAA,uBAA5BA,qBAAA,CAA8BvD,IAAI,QAAQM,QAAQ,CAACe,IAAI,iBAAiBU,KAAK,GAAG,CAAC,mBAAmB,CAAC;YAC3K,OAAO,CAAC;UACb;;UAEA;UACA,MAAMyB,aAAa,GAAGhD,CAAC,CAAC6C,kBAAkB,CAAC,CAACxC,IAAI,CAACL,CAAC,CAACM,cAAc,EAAEqB,IAAI;YAAA,IAAAsB,YAAA;YAAA,OACnE,CAAC,IAAI,EAAE,UAAU,EAAE,YAAY,EAAE,WAAW,EAAE,WAAW,EAAE,UAAU,CAAC,CAACC,QAAQ,EAAAD,YAAA,GAACtB,IAAI,CAACpB,MAAM,cAAA0C,YAAA,uBAAXA,YAAA,CAAazC,IAAI,CAAC;UAAA,EAAC;UACvG,CAAC;UAED,IAAIwC,aAAa,CAACtC,MAAM,KAAK,CAAC,EAAE;YAC5B;YACAgC,OAAO,GAAG,IAAI;UAClB;QAEJ,CAAC,CAAC,OAAOS,SAAS,EAAC;UAAA,IAAAC,sBAAA;UACdzD,OAAO,CAACC,KAAK,CAAC,mDAAAwD,sBAAA,GAAkDX,YAAY,CAACd,IAAI,CAACC,GAAG,cAAAwB,sBAAA,gBAAAA,sBAAA,GAArBA,sBAAA,CAAuB7D,KAAK,cAAA6D,sBAAA,uBAA5BA,sBAAA,CAA8B5D,IAAI,QAAQM,QAAQ,CAACe,IAAI,iBAAiBU,KAAK,GAAG,CAAC,GAAG,EAAE4B,SAAS,CAAC;UAChK;UACAT,OAAO,GAAG,KAAK;QACpB;QAGA,IAAIA,OAAO,EAAE;UACR;UACA,MAAMV,mBAAmB,GAAGS,YAAY,CAACR,UAAU;UACnD,IAAID,mBAAmB,CAACL,IAAI,CAACO,IAAI,KAAK,qBAAqB,EAAE;YAAA,IAAAmB,sBAAA;YACzDrD,CAAC,CAACgC,mBAAmB,CAAC,CAACG,MAAM,CAAC,CAAC;YAC/BxC,OAAO,CAACiB,GAAG,CAAC,yCAAAyC,sBAAA,GAAwCZ,YAAY,CAACd,IAAI,CAACC,GAAG,cAAAyB,sBAAA,gBAAAA,sBAAA,GAArBA,sBAAA,CAAuB9D,KAAK,cAAA8D,sBAAA,uBAA5BA,sBAAA,CAA8B7D,IAAI,gBAAgB+B,KAAK,GAAG,CAAC,EAAE,CAAC;UACtH,CAAC,MAAM;YAAA,IAAA+B,sBAAA;YACH3D,OAAO,CAAC0C,IAAI,CAAC,uCAAAiB,sBAAA,GAAsCb,YAAY,CAACd,IAAI,CAACC,GAAG,cAAA0B,sBAAA,gBAAAA,sBAAA,GAArBA,sBAAA,CAAuB/D,KAAK,cAAA+D,sBAAA,uBAA5BA,sBAAA,CAA8B9D,IAAI,+DAA+D,CAAC;UACzJ;QACL;MACJ,CAAC,CAAC;IACN,CAAC,CAAC,OAAOI,KAAK,EAAE;MACZD,OAAO,CAACC,KAAK,CAAC,oDAAoDE,QAAQ,CAACe,IAAI,iBAAiBU,KAAK,GAAG,CAAC,GAAG,EAAE3B,KAAK,CAAC;IACxH;IACA;;IAGA;IACA,MAAM2D,YAAY,GAAG/B,OAAO,CAACgC,QAAQ,CAAC;MAAEC,KAAK,EAAE,QAAQ;MAAEC,aAAa,EAAE;IAAK,CAAC,CAAC;;IAE/E;IACA,MAAMC,UAAU,GAAG9C,aAAI,CAAC+C,IAAI,CAAC7C,GAAG,EAAE,SAAS,CAAC,CAAC,CAAC;IAC9C,MAAM8C,WAAW,GAAG,GAAG1C,QAAQ,GAAGI,KAAK,GAAG,CAAC,GAAGN,GAAG,EAAE;IACnD,MAAM6C,WAAW,GAAGjD,aAAI,CAAC+C,IAAI,CAACD,UAAU,EAAEE,WAAW,CAAC,CAAC,CAAC;;IAExD;IACA,IAAI;MACA,IAAI,CAACE,WAAE,CAACC,UAAU,CAACL,UAAU,CAAC,EAAE;QAC5BI,WAAE,CAACE,SAAS,CAACN,UAAU,EAAE;UAAEO,SAAS,EAAE;QAAK,CAAC,CAAC;QAC7CvE,OAAO,CAACiB,GAAG,CAAC,sCAAsC+C,UAAU,EAAE,CAAC;MACnE;IACJ,CAAC,CAAC,OAAO/D,KAAK,EAAE;MACZD,OAAO,CAACC,KAAK,CAAC,4BAA4B+D,UAAU,GAAG,EAAE/D,KAAK,CAAC;MAC/D,OAAO,CAAC;IACZ;;IAGA;IACA,IAAI;MACFmE,WAAE,CAACI,aAAa,CAACL,WAAW,EAAEP,YAAY,CAAC;MAC3C5D,OAAO,CAACiB,GAAG,CAAC,cAAckD,WAAW,EAAE,CAAC;IAC1C,CAAC,CAAC,OAAOlE,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,6BAA6BkE,WAAW,GAAG,EAAElE,KAAK,CAAC;IACnE;EACF,CAAC,CAAC;;EAEF;EACA,OAAOe,SAAS;AAClB;;AAEA","ignoreList":[]}},"mtime":1746468081749},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\\\\split-specs5.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\30_04_25-15_05_25\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformer;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n// split-specs.js\n\n// --- Helper Function ---\nconst locationsAreEqual = (locA, locB) => {\n  if (!locA || !locB) return false;\n  try {\n    return locA.start.line === locB.start.line && locA.start.column === locB.start.column && locA.end.line === locB.end.line && locA.end.column === locB.end.column;\n  } catch (e) {\n    console.error(\"Error comparando localizaciones:\", e);\n    return false;\n  }\n};\n// --- Fin Helper ---\n\nfunction transformer(fileInfo, api) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n  const itPaths = root.find(j.CallExpression, {\n    callee: {\n      name: 'it'\n    }\n  }).paths();\n  if (itPaths.length <= 1) {\n    return undefined;\n  }\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\n  const originalPath = fileInfo.path;\n  const dir = _path.default.dirname(originalPath);\n  const ext = _path.default.extname(originalPath);\n  const baseName = _path.default.basename(originalPath, ext);\n  itPaths.forEach((targetItPath, index) => {\n    // 1. Crear copia fresca del AST\n    const astCopy = j(fileInfo.source);\n\n    // 2. Encontrar todos los 'it' en la copia\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\n      callee: {\n        name: 'it'\n      }\n    }).paths();\n\n    // 3. Obtener la ubicación del 'it' a conservar\n    const targetLoc = targetItPath.node.loc;\n    if (!targetLoc) {\n      console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\n      return;\n    }\n\n    // 4. Eliminar los 'it' cuya ubicación NO COINCIDA\n    allItPathsInCopy.forEach(currentItPathInCopy => {\n      const currentLoc = currentItPathInCopy.node.loc;\n      if (!locationsAreEqual(currentLoc, targetLoc)) {\n        try {\n          var _parentStatementPath$;\n          const parentStatementPath = currentItPathInCopy.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement' && (_parentStatementPath$ = parentStatementPath.parentPath) !== null && _parentStatementPath$ !== void 0 && (_parentStatementPath$ = _parentStatementPath$.node) !== null && _parentStatementPath$ !== void 0 && _parentStatementPath$.type) {\n            j(parentStatementPath).remove();\n          } else {\n            var _currentLoc$start;\n            j(currentItPathInCopy).remove();\n            console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start = currentLoc.start) === null || _currentLoc$start === void 0 ? void 0 : _currentLoc$start.line}). Revise el archivo ${index + 1}.`);\n          }\n        } catch (error) {\n          var _currentLoc$start2;\n          console.error(`Error eliminando bloque 'it' (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start2 = currentLoc.start) === null || _currentLoc$start2 === void 0 ? void 0 : _currentLoc$start2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\n        }\n      }\n    });\n\n    // 5. --- NUEVO PASO: Eliminar bloques 'describe' o 'context' vacíos ---\n    try {\n      const suitePaths = astCopy.find(j.CallExpression).filter(path => path.node.callee.type === 'Identifier' && ['describe', 'context'].includes(path.node.callee.name)).paths();\n\n      // Iterar en REVERSA es importante al eliminar nodos para no afectar índices/paths\n      suitePaths.reverse().forEach(suitePath => {\n        let isEffectivelyEmpty = false;\n        try {\n          // Acceder al cuerpo (BlockStatement) de la función del describe/context\n          const suiteFunc = suitePath.node.arguments[1]; // El callback es usualmente el 2º argumento\n          let blockStatementNode;\n          if (suiteFunc && (suiteFunc.type === 'FunctionExpression' || suiteFunc.type === 'ArrowFunctionExpression') && suiteFunc.body.type === 'BlockStatement') {\n            blockStatementNode = suiteFunc.body;\n          } else {\n            var _suitePath$node$loc;\n            console.warn(`Advertencia: Estructura inesperada en describe/context (línea ${(_suitePath$node$loc = suitePath.node.loc) === null || _suitePath$node$loc === void 0 || (_suitePath$node$loc = _suitePath$node$loc.start) === null || _suitePath$node$loc === void 0 ? void 0 : _suitePath$node$loc.line}) en ${fileInfo.path} para archivo ${index + 1}. No se considerará para limpieza.`);\n            return; // Saltar al siguiente suitePath\n          }\n\n          // Comprobar si el cuerpo contiene llamadas 'it'\n          const itCallsInBlock = j(blockStatementNode).find(j.CallExpression, {\n            callee: {\n              name: 'it'\n            }\n          });\n          if (itCallsInBlock.length === 0) {\n            // No hay llamadas 'it' en este bloque describe/context.\n            isEffectivelyEmpty = true;\n          }\n        } catch (findError) {\n          var _suitePath$node$loc2;\n          console.error(`Error inspeccionando cuerpo de describe/context (línea ${(_suitePath$node$loc2 = suitePath.node.loc) === null || _suitePath$node$loc2 === void 0 || (_suitePath$node$loc2 = _suitePath$node$loc2.start) === null || _suitePath$node$loc2 === void 0 ? void 0 : _suitePath$node$loc2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, findError);\n          isEffectivelyEmpty = false; // No eliminar si hubo error al inspeccionar\n        }\n        if (isEffectivelyEmpty) {\n          const parentStatementPath = suitePath.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement') {\n            var _suitePath$node$loc3;\n            j(parentStatementPath).remove();\n            console.log(`   - Describe/Context (línea ${(_suitePath$node$loc3 = suitePath.node.loc) === null || _suitePath$node$loc3 === void 0 || (_suitePath$node$loc3 = _suitePath$node$loc3.start) === null || _suitePath$node$loc3 === void 0 ? void 0 : _suitePath$node$loc3.line}) eliminado en archivo ${index + 1} por no contener bloques 'it'.`);\n          } else {\n            var _suitePath$node$loc4;\n            console.warn(`Advertencia: Describe/Context (línea ${(_suitePath$node$loc4 = suitePath.node.loc) === null || _suitePath$node$loc4 === void 0 || (_suitePath$node$loc4 = _suitePath$node$loc4.start) === null || _suitePath$node$loc4 === void 0 ? void 0 : _suitePath$node$loc4.line}) sin bloques 'it' no estaba en un ExpressionStatement directo y no se eliminó. Archivo ${index + 1}.`);\n          }\n        }\n      });\n    } catch (error) {\n      console.error(`Error durante la limpieza de bloques describe/context en ${fileInfo.path} para archivo ${index + 1}:`, error);\n    }\n    // --- FIN NUEVO PASO ---\n\n    // 5.1 --- NUEVO PASO: Desenvolver 'context' si solo contiene el bloque 'it' objetivo ---\n    try {\n      const contextCallPaths = astCopy.find(j.CallExpression, {\n        callee: {\n          name: 'context'\n        }\n      }).paths();\n      contextCallPaths.reverse().forEach(contextCallPath => {\n        const contextNode = contextCallPath.node;\n        if (!contextNode.arguments || contextNode.arguments.length < 2) return;\n        const contextCallback = contextNode.arguments[1];\n        if (!contextCallback || !contextCallback.body || contextCallback.body.type !== 'BlockStatement') return;\n        const contextBodyNode = contextCallback.body;\n        // Verificar que el cuerpo del context contenga exactamente una declaración\n        if (!contextBodyNode.body || contextBodyNode.body.length !== 1) {\n          return;\n        }\n        const singleStatementInContextBody = contextBodyNode.body[0];\n        // Verificar que la única declaración sea una ExpressionStatement que llama a 'it'\n        if (singleStatementInContextBody.type === 'ExpressionStatement' && singleStatementInContextBody.expression && singleStatementInContextBody.expression.type === 'CallExpression' && singleStatementInContextBody.expression.callee && singleStatementInContextBody.expression.callee.name === 'it') {\n          // Este 'context' contiene únicamente una llamada 'it'.\n          // Dado que otros 'it' fueron eliminados en el paso 4, este 'it' es el objetivo.\n          const contextStatementPath = contextCallPath.parentPath;\n          if (contextStatementPath.node.type === 'ExpressionStatement') {\n            var _contextNode$loc;\n            // Reemplazar el ExpressionStatement del 'context' con el ExpressionStatement del 'it'\n            j(contextStatementPath).replaceWith(singleStatementInContextBody);\n            console.log(`   - Contexto desenvuelto (línea ${(_contextNode$loc = contextNode.loc) === null || _contextNode$loc === void 0 || (_contextNode$loc = _contextNode$loc.start) === null || _contextNode$loc === void 0 ? void 0 : _contextNode$loc.line}) en archivo ${index + 1} porque solo contenía un bloque 'it'.`);\n          } else {\n            var _contextNode$loc2;\n            console.warn(`Advertencia: Contexto (línea ${(_contextNode$loc2 = contextNode.loc) === null || _contextNode$loc2 === void 0 || (_contextNode$loc2 = _contextNode$loc2.start) === null || _contextNode$loc2 === void 0 ? void 0 : _contextNode$loc2.line}) que solo contenía un 'it' no estaba en un ExpressionStatement directo. No se desenvolvió en archivo ${index + 1}.`);\n          }\n        }\n      });\n    } catch (error) {\n      console.error(`Error durante el desenvolvimiento de bloques 'context' en ${fileInfo.path} para archivo ${index + 1}:`, error);\n    }\n    // --- FIN NUEVO PASO 5.1 ---\n\n    // 6. Generar código fuente desde el AST modificado (ahora también sin describes vacíos)\n    const outputSource = astCopy.toSource({\n      quote: 'single',\n      trailingComma: true\n    });\n\n    // 7. Construir nuevo nombre de archivo y ruta de directorio de resultados\n    const resultsDir = _path.default.join(dir, 'results'); // Directorio de resultados\n\n    let newFileName;\n    if (baseName.endsWith('.spec')) {\n      const nameWithoutSpec = baseName.substring(0, baseName.length - '.spec'.length);\n      newFileName = `${nameWithoutSpec}${index + 1}.spec${ext}`;\n    } else {\n      // Fallback for other naming conventions if needed, or stick to original logic\n      // For now, let's assume files are *.spec.ext or handle as an error/warning\n      // Sticking to a modified version of original logic for non .spec files for broader compatibility\n      newFileName = `${baseName}${index + 1}${ext}`;\n      console.warn(`   Advertencia: El archivo base \"${baseName}${ext}\" no termina con '.spec'. Se usó el formato de nombre: ${newFileName}`);\n    }\n    // const newFileName = `${baseName}${index + 1}${ext}`; // Original line\n    const newFilePath = _path.default.join(resultsDir, newFileName); // Ruta completa en 'results'\n\n    // 8. Asegurarse de que el directorio 'results' exista\n    try {\n      if (!_fs.default.existsSync(resultsDir)) {\n        _fs.default.mkdirSync(resultsDir, {\n          recursive: true\n        });\n        console.log(`   Directorio 'results' creado en: ${resultsDir}`);\n      }\n    } catch (error) {\n      console.error(`Error creando directorio ${resultsDir}:`, error);\n      return; // No continuar si no se puede crear el directorio\n    }\n\n    // 9. Escribir el nuevo archivo en el directorio 'results'\n    try {\n      _fs.default.writeFileSync(newFilePath, outputSource);\n      console.log(`   Creado: ${newFilePath}`);\n    } catch (error) {\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\n    }\n  });\n\n  // Devolver undefined/null para no modificar el original\n  return undefined;\n}\n\n// export const parser = 'ts';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZnMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9wYXRoIiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwibG9jYXRpb25zQXJlRXF1YWwiLCJsb2NBIiwibG9jQiIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsImVuZCIsImNvbnNvbGUiLCJlcnJvciIsInRyYW5zZm9ybWVyIiwiZmlsZUluZm8iLCJhcGkiLCJqIiwianNjb2Rlc2hpZnQiLCJyb290Iiwic291cmNlIiwiaXRQYXRocyIsImZpbmQiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsIm5hbWUiLCJwYXRocyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImxvZyIsInBhdGgiLCJvcmlnaW5hbFBhdGgiLCJkaXIiLCJkaXJuYW1lIiwiZXh0IiwiZXh0bmFtZSIsImJhc2VOYW1lIiwiYmFzZW5hbWUiLCJmb3JFYWNoIiwidGFyZ2V0SXRQYXRoIiwiaW5kZXgiLCJhc3RDb3B5IiwiYWxsSXRQYXRoc0luQ29weSIsInRhcmdldExvYyIsIm5vZGUiLCJsb2MiLCJjdXJyZW50SXRQYXRoSW5Db3B5IiwiY3VycmVudExvYyIsIl9wYXJlbnRTdGF0ZW1lbnRQYXRoJCIsInBhcmVudFN0YXRlbWVudFBhdGgiLCJwYXJlbnRQYXRoIiwidHlwZSIsInJlbW92ZSIsIl9jdXJyZW50TG9jJHN0YXJ0Iiwid2FybiIsIl9jdXJyZW50TG9jJHN0YXJ0MiIsInN1aXRlUGF0aHMiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsInJldmVyc2UiLCJzdWl0ZVBhdGgiLCJpc0VmZmVjdGl2ZWx5RW1wdHkiLCJzdWl0ZUZ1bmMiLCJhcmd1bWVudHMiLCJibG9ja1N0YXRlbWVudE5vZGUiLCJib2R5IiwiX3N1aXRlUGF0aCRub2RlJGxvYyIsIml0Q2FsbHNJbkJsb2NrIiwiZmluZEVycm9yIiwiX3N1aXRlUGF0aCRub2RlJGxvYzIiLCJfc3VpdGVQYXRoJG5vZGUkbG9jMyIsIl9zdWl0ZVBhdGgkbm9kZSRsb2M0IiwiY29udGV4dENhbGxQYXRocyIsImNvbnRleHRDYWxsUGF0aCIsImNvbnRleHROb2RlIiwiY29udGV4dENhbGxiYWNrIiwiY29udGV4dEJvZHlOb2RlIiwic2luZ2xlU3RhdGVtZW50SW5Db250ZXh0Qm9keSIsImV4cHJlc3Npb24iLCJjb250ZXh0U3RhdGVtZW50UGF0aCIsIl9jb250ZXh0Tm9kZSRsb2MiLCJyZXBsYWNlV2l0aCIsIl9jb250ZXh0Tm9kZSRsb2MyIiwib3V0cHV0U291cmNlIiwidG9Tb3VyY2UiLCJxdW90ZSIsInRyYWlsaW5nQ29tbWEiLCJyZXN1bHRzRGlyIiwiam9pbiIsIm5ld0ZpbGVOYW1lIiwiZW5kc1dpdGgiLCJuYW1lV2l0aG91dFNwZWMiLCJzdWJzdHJpbmciLCJuZXdGaWxlUGF0aCIsImZzIiwiZXhpc3RzU3luYyIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsIndyaXRlRmlsZVN5bmMiXSwic291cmNlUm9vdCI6IkM6XFxVc2Vyc1xceGFiaWFcXE9uZURyaXZlXFxEb2N1bWVudG9zXFw0Lk1haWxhXFxURkctQmVzdGVsYWtvYWtcXEJlc3RlbGFrb2FrXFwzMF8wNF8yNS0xNV8wNV8yNVxcc3BsaXRJVEpDb2RlU2hpZnRcXCIsInNvdXJjZXMiOlsic3BsaXQtc3BlY3M1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNwbGl0LXNwZWNzLmpzXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuLy8gLS0tIEhlbHBlciBGdW5jdGlvbiAtLS1cclxuY29uc3QgbG9jYXRpb25zQXJlRXF1YWwgPSAobG9jQSwgbG9jQikgPT4ge1xyXG4gICAgaWYgKCFsb2NBIHx8ICFsb2NCKSByZXR1cm4gZmFsc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGxvY0Euc3RhcnQubGluZSA9PT0gbG9jQi5zdGFydC5saW5lICYmXHJcbiAgICAgICAgICAgIGxvY0Euc3RhcnQuY29sdW1uID09PSBsb2NCLnN0YXJ0LmNvbHVtbiAmJlxyXG4gICAgICAgICAgICBsb2NBLmVuZC5saW5lID09PSBsb2NCLmVuZC5saW5lICYmXHJcbiAgICAgICAgICAgIGxvY0EuZW5kLmNvbHVtbiA9PT0gbG9jQi5lbmQuY29sdW1uXHJcbiAgICAgICAgKTtcclxuICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb21wYXJhbmRvIGxvY2FsaXphY2lvbmVzOlwiLCBlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbi8vIC0tLSBGaW4gSGVscGVyIC0tLVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNmb3JtZXIoZmlsZUluZm8sIGFwaSkge1xyXG4gIGNvbnN0IGogPSBhcGkuanNjb2Rlc2hpZnQ7XHJcbiAgY29uc3Qgcm9vdCA9IGooZmlsZUluZm8uc291cmNlKTtcclxuXHJcbiAgY29uc3QgaXRQYXRocyA9IHJvb3QuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICBjYWxsZWU6IHsgbmFtZTogJ2l0JyB9LFxyXG4gIH0pLnBhdGhzKCk7XHJcblxyXG4gIGlmIChpdFBhdGhzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coYC0+IEFyY2hpdm8gJHtmaWxlSW5mby5wYXRofTogJHtpdFBhdGhzLmxlbmd0aH0gYmxvcXVlKHMpICdpdCcgZW5jb250cmFkb3MuIEdlbmVyYW5kbyBhcmNoaXZvcyBpbmRpdmlkdWFsZXMuLi5gKTtcclxuXHJcbiAgY29uc3Qgb3JpZ2luYWxQYXRoID0gZmlsZUluZm8ucGF0aDtcclxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUob3JpZ2luYWxQYXRoKTtcclxuICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUob3JpZ2luYWxQYXRoKTtcclxuICBjb25zdCBiYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUob3JpZ2luYWxQYXRoLCBleHQpO1xyXG5cclxuICBpdFBhdGhzLmZvckVhY2goKHRhcmdldEl0UGF0aCwgaW5kZXgpID0+IHtcclxuICAgIC8vIDEuIENyZWFyIGNvcGlhIGZyZXNjYSBkZWwgQVNUXHJcbiAgICBjb25zdCBhc3RDb3B5ID0gaihmaWxlSW5mby5zb3VyY2UpO1xyXG5cclxuICAgIC8vIDIuIEVuY29udHJhciB0b2RvcyBsb3MgJ2l0JyBlbiBsYSBjb3BpYVxyXG4gICAgY29uc3QgYWxsSXRQYXRoc0luQ29weSA9IGFzdENvcHkuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICAgICAgY2FsbGVlOiB7IG5hbWU6ICdpdCcgfSxcclxuICAgICAgfSkucGF0aHMoKTtcclxuXHJcbiAgICAvLyAzLiBPYnRlbmVyIGxhIHViaWNhY2nDs24gZGVsICdpdCcgYSBjb25zZXJ2YXJcclxuICAgIGNvbnN0IHRhcmdldExvYyA9IHRhcmdldEl0UGF0aC5ub2RlLmxvYztcclxuICAgIGlmICghdGFyZ2V0TG9jKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgQ3LDrXRpY286IEZhbHRhIGluZm9ybWFjacOzbiBkZSB1YmljYWNpw7NuIHBhcmEgZWwgYmxvcXVlICdpdCcgKMOtbmRpY2UgJHtpbmRleH0pIGVuICR7ZmlsZUluZm8ucGF0aH0uIE5vIHNlIHB1ZWRlIGdlbmVyYXIgYXJjaGl2byAke2luZGV4ICsgMX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDQuIEVsaW1pbmFyIGxvcyAnaXQnIGN1eWEgdWJpY2FjacOzbiBOTyBDT0lOQ0lEQVxyXG4gICAgYWxsSXRQYXRoc0luQ29weS5mb3JFYWNoKGN1cnJlbnRJdFBhdGhJbkNvcHkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRMb2MgPSBjdXJyZW50SXRQYXRoSW5Db3B5Lm5vZGUubG9jO1xyXG4gICAgICAgIGlmICghbG9jYXRpb25zQXJlRXF1YWwoY3VycmVudExvYywgdGFyZ2V0TG9jKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0YXRlbWVudFBhdGggPSBjdXJyZW50SXRQYXRoSW5Db3B5LnBhcmVudFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlbWVudFBhdGgubm9kZS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgJiYgcGFyZW50U3RhdGVtZW50UGF0aC5wYXJlbnRQYXRoPy5ub2RlPy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGoocGFyZW50U3RhdGVtZW50UGF0aCkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgaihjdXJyZW50SXRQYXRoSW5Db3B5KS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBZHZlcnRlbmNpYTogRXN0cnVjdHVyYSBpbmVzcGVyYWRhIHBhcmEgYmxvcXVlICdpdCcgZW4gJHtmaWxlSW5mby5wYXRofSAobMOtbmVhICR7Y3VycmVudExvYz8uc3RhcnQ/LmxpbmV9KS4gUmV2aXNlIGVsIGFyY2hpdm8gJHtpbmRleCArIDF9LmApO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVsaW1pbmFuZG8gYmxvcXVlICdpdCcgKGzDrW5lYSAke2N1cnJlbnRMb2M/LnN0YXJ0Py5saW5lfSkgZW4gJHtmaWxlSW5mby5wYXRofSBwYXJhIGFyY2hpdm8gJHtpbmRleCArIDF9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDUuIC0tLSBOVUVWTyBQQVNPOiBFbGltaW5hciBibG9xdWVzICdkZXNjcmliZScgbyAnY29udGV4dCcgdmFjw61vcyAtLS1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgc3VpdGVQYXRocyA9IGFzdENvcHkuZmluZChqLkNhbGxFeHByZXNzaW9uKVxyXG4gICAgICAgICAgICAuZmlsdGVyKHBhdGggPT5cclxuICAgICAgICAgICAgICAgIHBhdGgubm9kZS5jYWxsZWUudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXHJcbiAgICAgICAgICAgICAgICBbJ2Rlc2NyaWJlJywgJ2NvbnRleHQnXS5pbmNsdWRlcyhwYXRoLm5vZGUuY2FsbGVlLm5hbWUpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgLnBhdGhzKCk7XHJcblxyXG4gICAgICAgIC8vIEl0ZXJhciBlbiBSRVZFUlNBIGVzIGltcG9ydGFudGUgYWwgZWxpbWluYXIgbm9kb3MgcGFyYSBubyBhZmVjdGFyIMOtbmRpY2VzL3BhdGhzXHJcbiAgICAgICAgc3VpdGVQYXRocy5yZXZlcnNlKCkuZm9yRWFjaChzdWl0ZVBhdGggPT4ge1xyXG4gICAgICAgICAgICBsZXQgaXNFZmZlY3RpdmVseUVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBY2NlZGVyIGFsIGN1ZXJwbyAoQmxvY2tTdGF0ZW1lbnQpIGRlIGxhIGZ1bmNpw7NuIGRlbCBkZXNjcmliZS9jb250ZXh0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdWl0ZUZ1bmMgPSBzdWl0ZVBhdGgubm9kZS5hcmd1bWVudHNbMV07IC8vIEVsIGNhbGxiYWNrIGVzIHVzdWFsbWVudGUgZWwgMsK6IGFyZ3VtZW50b1xyXG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrU3RhdGVtZW50Tm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3VpdGVGdW5jICYmIChzdWl0ZUZ1bmMudHlwZSA9PT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicgfHwgc3VpdGVGdW5jLnR5cGUgPT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicpICYmIHN1aXRlRnVuYy5ib2R5LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgYmxvY2tTdGF0ZW1lbnROb2RlID0gc3VpdGVGdW5jLmJvZHk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFkdmVydGVuY2lhOiBFc3RydWN0dXJhIGluZXNwZXJhZGEgZW4gZGVzY3JpYmUvY29udGV4dCAobMOtbmVhICR7c3VpdGVQYXRoLm5vZGUubG9jPy5zdGFydD8ubGluZX0pIGVuICR7ZmlsZUluZm8ucGF0aH0gcGFyYSBhcmNoaXZvICR7aW5kZXggKyAxfS4gTm8gc2UgY29uc2lkZXJhcsOhIHBhcmEgbGltcGllemEuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU2FsdGFyIGFsIHNpZ3VpZW50ZSBzdWl0ZVBhdGhcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wcm9iYXIgc2kgZWwgY3VlcnBvIGNvbnRpZW5lIGxsYW1hZGFzICdpdCdcclxuICAgICAgICAgICAgICAgIGNvbnN0IGl0Q2FsbHNJbkJsb2NrID0gaihibG9ja1N0YXRlbWVudE5vZGUpLmZpbmQoai5DYWxsRXhwcmVzc2lvbiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZTogeyBuYW1lOiAnaXQnIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpdENhbGxzSW5CbG9jay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBoYXkgbGxhbWFkYXMgJ2l0JyBlbiBlc3RlIGJsb3F1ZSBkZXNjcmliZS9jb250ZXh0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlzRWZmZWN0aXZlbHlFbXB0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGNhdGNoIChmaW5kRXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluc3BlY2Npb25hbmRvIGN1ZXJwbyBkZSBkZXNjcmliZS9jb250ZXh0IChsw61uZWEgJHtzdWl0ZVBhdGgubm9kZS5sb2M/LnN0YXJ0Py5saW5lfSkgZW4gJHtmaWxlSW5mby5wYXRofSBwYXJhIGFyY2hpdm8gJHtpbmRleCArIDF9OmAsIGZpbmRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgaXNFZmZlY3RpdmVseUVtcHR5ID0gZmFsc2U7IC8vIE5vIGVsaW1pbmFyIHNpIGh1Ym8gZXJyb3IgYWwgaW5zcGVjY2lvbmFyXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpc0VmZmVjdGl2ZWx5RW1wdHkpIHtcclxuICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRTdGF0ZW1lbnRQYXRoID0gc3VpdGVQYXRoLnBhcmVudFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlbWVudFBhdGgubm9kZS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgaihwYXJlbnRTdGF0ZW1lbnRQYXRoKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIC0gRGVzY3JpYmUvQ29udGV4dCAobMOtbmVhICR7c3VpdGVQYXRoLm5vZGUubG9jPy5zdGFydD8ubGluZX0pIGVsaW1pbmFkbyBlbiBhcmNoaXZvICR7aW5kZXggKyAxfSBwb3Igbm8gY29udGVuZXIgYmxvcXVlcyAnaXQnLmApO1xyXG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQWR2ZXJ0ZW5jaWE6IERlc2NyaWJlL0NvbnRleHQgKGzDrW5lYSAke3N1aXRlUGF0aC5ub2RlLmxvYz8uc3RhcnQ/LmxpbmV9KSBzaW4gYmxvcXVlcyAnaXQnIG5vIGVzdGFiYSBlbiB1biBFeHByZXNzaW9uU3RhdGVtZW50IGRpcmVjdG8geSBubyBzZSBlbGltaW7Dsy4gQXJjaGl2byAke2luZGV4ICsgMX0uYCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmFudGUgbGEgbGltcGllemEgZGUgYmxvcXVlcyBkZXNjcmliZS9jb250ZXh0IGVuICR7ZmlsZUluZm8ucGF0aH0gcGFyYSBhcmNoaXZvICR7aW5kZXggKyAxfTpgLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0gRklOIE5VRVZPIFBBU08gLS0tXHJcblxyXG4gICAgLy8gNS4xIC0tLSBOVUVWTyBQQVNPOiBEZXNlbnZvbHZlciAnY29udGV4dCcgc2kgc29sbyBjb250aWVuZSBlbCBibG9xdWUgJ2l0JyBvYmpldGl2byAtLS1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dENhbGxQYXRocyA9IGFzdENvcHkuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICAgICAgICAgIGNhbGxlZTogeyBuYW1lOiAnY29udGV4dCcgfVxyXG4gICAgICAgIH0pLnBhdGhzKCk7XHJcblxyXG4gICAgICAgIGNvbnRleHRDYWxsUGF0aHMucmV2ZXJzZSgpLmZvckVhY2goY29udGV4dENhbGxQYXRoID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dE5vZGUgPSBjb250ZXh0Q2FsbFBhdGgubm9kZTtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0Tm9kZS5hcmd1bWVudHMgfHwgY29udGV4dE5vZGUuYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRDYWxsYmFjayA9IGNvbnRleHROb2RlLmFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0Q2FsbGJhY2sgfHwgIWNvbnRleHRDYWxsYmFjay5ib2R5IHx8IGNvbnRleHRDYWxsYmFjay5ib2R5LnR5cGUgIT09ICdCbG9ja1N0YXRlbWVudCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRCb2R5Tm9kZSA9IGNvbnRleHRDYWxsYmFjay5ib2R5O1xyXG4gICAgICAgICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGN1ZXJwbyBkZWwgY29udGV4dCBjb250ZW5nYSBleGFjdGFtZW50ZSB1bmEgZGVjbGFyYWNpw7NuXHJcbiAgICAgICAgICAgIGlmICghY29udGV4dEJvZHlOb2RlLmJvZHkgfHwgY29udGV4dEJvZHlOb2RlLmJvZHkubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVN0YXRlbWVudEluQ29udGV4dEJvZHkgPSBjb250ZXh0Qm9keU5vZGUuYm9keVswXTtcclxuICAgICAgICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBsYSDDum5pY2EgZGVjbGFyYWNpw7NuIHNlYSB1bmEgRXhwcmVzc2lvblN0YXRlbWVudCBxdWUgbGxhbWEgYSAnaXQnXHJcbiAgICAgICAgICAgIGlmIChzaW5nbGVTdGF0ZW1lbnRJbkNvbnRleHRCb2R5LnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyAmJlxyXG4gICAgICAgICAgICAgICAgc2luZ2xlU3RhdGVtZW50SW5Db250ZXh0Qm9keS5leHByZXNzaW9uICYmXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVTdGF0ZW1lbnRJbkNvbnRleHRCb2R5LmV4cHJlc3Npb24udHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgc2luZ2xlU3RhdGVtZW50SW5Db250ZXh0Qm9keS5leHByZXNzaW9uLmNhbGxlZSAmJlxyXG4gICAgICAgICAgICAgICAgc2luZ2xlU3RhdGVtZW50SW5Db250ZXh0Qm9keS5leHByZXNzaW9uLmNhbGxlZS5uYW1lID09PSAnaXQnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXN0ZSAnY29udGV4dCcgY29udGllbmUgw7puaWNhbWVudGUgdW5hIGxsYW1hZGEgJ2l0Jy5cclxuICAgICAgICAgICAgICAgIC8vIERhZG8gcXVlIG90cm9zICdpdCcgZnVlcm9uIGVsaW1pbmFkb3MgZW4gZWwgcGFzbyA0LCBlc3RlICdpdCcgZXMgZWwgb2JqZXRpdm8uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0U3RhdGVtZW50UGF0aCA9IGNvbnRleHRDYWxsUGF0aC5wYXJlbnRQYXRoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRTdGF0ZW1lbnRQYXRoLm5vZGUudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVlbXBsYXphciBlbCBFeHByZXNzaW9uU3RhdGVtZW50IGRlbCAnY29udGV4dCcgY29uIGVsIEV4cHJlc3Npb25TdGF0ZW1lbnQgZGVsICdpdCdcclxuICAgICAgICAgICAgICAgICAgICBqKGNvbnRleHRTdGF0ZW1lbnRQYXRoKS5yZXBsYWNlV2l0aChzaW5nbGVTdGF0ZW1lbnRJbkNvbnRleHRCb2R5KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgLSBDb250ZXh0byBkZXNlbnZ1ZWx0byAobMOtbmVhICR7Y29udGV4dE5vZGUubG9jPy5zdGFydD8ubGluZX0pIGVuIGFyY2hpdm8gJHtpbmRleCArIDF9IHBvcnF1ZSBzb2xvIGNvbnRlbsOtYSB1biBibG9xdWUgJ2l0Jy5gKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBZHZlcnRlbmNpYTogQ29udGV4dG8gKGzDrW5lYSAke2NvbnRleHROb2RlLmxvYz8uc3RhcnQ/LmxpbmV9KSBxdWUgc29sbyBjb250ZW7DrWEgdW4gJ2l0JyBubyBlc3RhYmEgZW4gdW4gRXhwcmVzc2lvblN0YXRlbWVudCBkaXJlY3RvLiBObyBzZSBkZXNlbnZvbHZpw7MgZW4gYXJjaGl2byAke2luZGV4ICsgMX0uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZHVyYW50ZSBlbCBkZXNlbnZvbHZpbWllbnRvIGRlIGJsb3F1ZXMgJ2NvbnRleHQnIGVuICR7ZmlsZUluZm8ucGF0aH0gcGFyYSBhcmNoaXZvICR7aW5kZXggKyAxfTpgLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0gRklOIE5VRVZPIFBBU08gNS4xIC0tLVxyXG5cclxuICAgIC8vIDYuIEdlbmVyYXIgY8OzZGlnbyBmdWVudGUgZGVzZGUgZWwgQVNUIG1vZGlmaWNhZG8gKGFob3JhIHRhbWJpw6luIHNpbiBkZXNjcmliZXMgdmFjw61vcylcclxuICAgIGNvbnN0IG91dHB1dFNvdXJjZSA9IGFzdENvcHkudG9Tb3VyY2UoeyBxdW90ZTogJ3NpbmdsZScsIHRyYWlsaW5nQ29tbWE6IHRydWUgfSk7XHJcblxyXG4gICAgLy8gNy4gQ29uc3RydWlyIG51ZXZvIG5vbWJyZSBkZSBhcmNoaXZvIHkgcnV0YSBkZSBkaXJlY3RvcmlvIGRlIHJlc3VsdGFkb3NcclxuICAgIGNvbnN0IHJlc3VsdHNEaXIgPSBwYXRoLmpvaW4oZGlyLCAncmVzdWx0cycpOyAvLyBEaXJlY3RvcmlvIGRlIHJlc3VsdGFkb3NcclxuICAgIFxyXG4gICAgbGV0IG5ld0ZpbGVOYW1lO1xyXG4gICAgaWYgKGJhc2VOYW1lLmVuZHNXaXRoKCcuc3BlYycpKSB7XHJcbiAgICAgIGNvbnN0IG5hbWVXaXRob3V0U3BlYyA9IGJhc2VOYW1lLnN1YnN0cmluZygwLCBiYXNlTmFtZS5sZW5ndGggLSAnLnNwZWMnLmxlbmd0aCk7XHJcbiAgICAgIG5ld0ZpbGVOYW1lID0gYCR7bmFtZVdpdGhvdXRTcGVjfSR7aW5kZXggKyAxfS5zcGVjJHtleHR9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEZhbGxiYWNrIGZvciBvdGhlciBuYW1pbmcgY29udmVudGlvbnMgaWYgbmVlZGVkLCBvciBzdGljayB0byBvcmlnaW5hbCBsb2dpY1xyXG4gICAgICAvLyBGb3Igbm93LCBsZXQncyBhc3N1bWUgZmlsZXMgYXJlICouc3BlYy5leHQgb3IgaGFuZGxlIGFzIGFuIGVycm9yL3dhcm5pbmdcclxuICAgICAgLy8gU3RpY2tpbmcgdG8gYSBtb2RpZmllZCB2ZXJzaW9uIG9mIG9yaWdpbmFsIGxvZ2ljIGZvciBub24gLnNwZWMgZmlsZXMgZm9yIGJyb2FkZXIgY29tcGF0aWJpbGl0eVxyXG4gICAgICBuZXdGaWxlTmFtZSA9IGAke2Jhc2VOYW1lfSR7aW5kZXggKyAxfSR7ZXh0fWA7XHJcbiAgICAgIGNvbnNvbGUud2FybihgICAgQWR2ZXJ0ZW5jaWE6IEVsIGFyY2hpdm8gYmFzZSBcIiR7YmFzZU5hbWV9JHtleHR9XCIgbm8gdGVybWluYSBjb24gJy5zcGVjJy4gU2UgdXPDsyBlbCBmb3JtYXRvIGRlIG5vbWJyZTogJHtuZXdGaWxlTmFtZX1gKTtcclxuICAgIH1cclxuICAgIC8vIGNvbnN0IG5ld0ZpbGVOYW1lID0gYCR7YmFzZU5hbWV9JHtpbmRleCArIDF9JHtleHR9YDsgLy8gT3JpZ2luYWwgbGluZVxyXG4gICAgY29uc3QgbmV3RmlsZVBhdGggPSBwYXRoLmpvaW4ocmVzdWx0c0RpciwgbmV3RmlsZU5hbWUpOyAvLyBSdXRhIGNvbXBsZXRhIGVuICdyZXN1bHRzJ1xyXG5cclxuICAgIC8vIDguIEFzZWd1cmFyc2UgZGUgcXVlIGVsIGRpcmVjdG9yaW8gJ3Jlc3VsdHMnIGV4aXN0YVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocmVzdWx0c0RpcikpIHtcclxuICAgICAgICAgICAgZnMubWtkaXJTeW5jKHJlc3VsdHNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgRGlyZWN0b3JpbyAncmVzdWx0cycgY3JlYWRvIGVuOiAke3Jlc3VsdHNEaXJ9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhbmRvIGRpcmVjdG9yaW8gJHtyZXN1bHRzRGlyfTpgLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBObyBjb250aW51YXIgc2kgbm8gc2UgcHVlZGUgY3JlYXIgZWwgZGlyZWN0b3Jpb1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyA5LiBFc2NyaWJpciBlbCBudWV2byBhcmNoaXZvIGVuIGVsIGRpcmVjdG9yaW8gJ3Jlc3VsdHMnXHJcbiAgICB0cnkge1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKG5ld0ZpbGVQYXRoLCBvdXRwdXRTb3VyY2UpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgICAgQ3JlYWRvOiAke25ld0ZpbGVQYXRofWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZXNjcmliaWVuZG8gYXJjaGl2byAke25ld0ZpbGVQYXRofTpgLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIERldm9sdmVyIHVuZGVmaW5lZC9udWxsIHBhcmEgbm8gbW9kaWZpY2FyIGVsIG9yaWdpbmFsXHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuLy8gZXhwb3J0IGNvbnN0IHBhcnNlciA9ICd0cyc7Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxJQUFBQSxHQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxLQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFBd0IsU0FBQUQsdUJBQUFHLENBQUEsV0FBQUEsQ0FBQSxJQUFBQSxDQUFBLENBQUFDLFVBQUEsR0FBQUQsQ0FBQSxLQUFBRSxPQUFBLEVB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","map":{"version":3,"names":["_fs","_interopRequireDefault","require","_path","e","__esModule","default","locationsAreEqual","locA","locB","start","line","column","end","console","error","transformer","fileInfo","api","j","jscodeshift","root","source","itPaths","find","CallExpression","callee","name","paths","length","undefined","log","path","originalPath","dir","dirname","ext","extname","baseName","basename","forEach","targetItPath","index","astCopy","allItPathsInCopy","targetLoc","node","loc","currentItPathInCopy","currentLoc","_parentStatementPath$","parentStatementPath","parentPath","type","remove","_currentLoc$start","warn","_currentLoc$start2","suitePaths","filter","includes","reverse","suitePath","isEffectivelyEmpty","suiteFunc","arguments","blockStatementNode","body","_suitePath$node$loc","itCallsInBlock","findError","_suitePath$node$loc2","_suitePath$node$loc3","_suitePath$node$loc4","contextCallPaths","contextCallPath","contextNode","contextCallback","contextBodyNode","singleStatementInContextBody","expression","contextStatementPath","_contextNode$loc","replaceWith","_contextNode$loc2","outputSource","toSource","quote","trailingComma","resultsDir","join","newFileName","endsWith","nameWithoutSpec","substring","newFilePath","fs","existsSync","mkdirSync","recursive","writeFileSync"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\30_04_25-15_05_25\\splitITJCodeShift\\","sources":["split-specs5.js"],"sourcesContent":["// split-specs.js\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\n// --- Helper Function ---\r\nconst locationsAreEqual = (locA, locB) => {\r\n    if (!locA || !locB) return false;\r\n    try {\r\n        return (\r\n            locA.start.line === locB.start.line &&\r\n            locA.start.column === locB.start.column &&\r\n            locA.end.line === locB.end.line &&\r\n            locA.end.column === locB.end.column\r\n        );\r\n    } catch(e) {\r\n        console.error(\"Error comparando localizaciones:\", e);\r\n        return false;\r\n    }\r\n};\r\n// --- Fin Helper ---\r\n\r\nexport default function transformer(fileInfo, api) {\r\n  const j = api.jscodeshift;\r\n  const root = j(fileInfo.source);\r\n\r\n  const itPaths = root.find(j.CallExpression, {\r\n    callee: { name: 'it' },\r\n  }).paths();\r\n\r\n  if (itPaths.length <= 1) {\r\n    return undefined;\r\n  }\r\n\r\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\r\n\r\n  const originalPath = fileInfo.path;\r\n  const dir = path.dirname(originalPath);\r\n  const ext = path.extname(originalPath);\r\n  const baseName = path.basename(originalPath, ext);\r\n\r\n  itPaths.forEach((targetItPath, index) => {\r\n    // 1. Crear copia fresca del AST\r\n    const astCopy = j(fileInfo.source);\r\n\r\n    // 2. Encontrar todos los 'it' en la copia\r\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\r\n        callee: { name: 'it' },\r\n      }).paths();\r\n\r\n    // 3. Obtener la ubicación del 'it' a conservar\r\n    const targetLoc = targetItPath.node.loc;\r\n    if (!targetLoc) {\r\n        console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\r\n        return;\r\n    }\r\n\r\n    // 4. Eliminar los 'it' cuya ubicación NO COINCIDA\r\n    allItPathsInCopy.forEach(currentItPathInCopy => {\r\n        const currentLoc = currentItPathInCopy.node.loc;\r\n        if (!locationsAreEqual(currentLoc, targetLoc)) {\r\n            try {\r\n                 const parentStatementPath = currentItPathInCopy.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement' && parentStatementPath.parentPath?.node?.type) {\r\n                     j(parentStatementPath).remove();\r\n                 } else {\r\n                     j(currentItPathInCopy).remove();\r\n                     console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc?.start?.line}). Revise el archivo ${index + 1}.`);\r\n                 }\r\n            } catch (error) {\r\n                console.error(`Error eliminando bloque 'it' (línea ${currentLoc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n            }\r\n        }\r\n    });\r\n\r\n    // 5. --- NUEVO PASO: Eliminar bloques 'describe' o 'context' vacíos ---\r\n    try {\r\n        const suitePaths = astCopy.find(j.CallExpression)\r\n            .filter(path =>\r\n                path.node.callee.type === 'Identifier' &&\r\n                ['describe', 'context'].includes(path.node.callee.name)\r\n            )\r\n            .paths();\r\n\r\n        // Iterar en REVERSA es importante al eliminar nodos para no afectar índices/paths\r\n        suitePaths.reverse().forEach(suitePath => {\r\n            let isEffectivelyEmpty = false;\r\n            try {\r\n                // Acceder al cuerpo (BlockStatement) de la función del describe/context\r\n                const suiteFunc = suitePath.node.arguments[1]; // El callback es usualmente el 2º argumento\r\n                let blockStatementNode;\r\n\r\n                if (suiteFunc && (suiteFunc.type === 'FunctionExpression' || suiteFunc.type === 'ArrowFunctionExpression') && suiteFunc.body.type === 'BlockStatement') {\r\n                     blockStatementNode = suiteFunc.body;\r\n                } else {\r\n                     console.warn(`Advertencia: Estructura inesperada en describe/context (línea ${suitePath.node.loc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}. No se considerará para limpieza.`);\r\n                     return; // Saltar al siguiente suitePath\r\n                }\r\n\r\n                // Comprobar si el cuerpo contiene llamadas 'it'\r\n                const itCallsInBlock = j(blockStatementNode).find(j.CallExpression, {\r\n                    callee: { name: 'it' }\r\n                });\r\n\r\n                if (itCallsInBlock.length === 0) {\r\n                    // No hay llamadas 'it' en este bloque describe/context.\r\n                    isEffectivelyEmpty = true;\r\n                }\r\n\r\n            } catch (findError){\r\n                 console.error(`Error inspeccionando cuerpo de describe/context (línea ${suitePath.node.loc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, findError);\r\n                 isEffectivelyEmpty = false; // No eliminar si hubo error al inspeccionar\r\n            }\r\n\r\n            if (isEffectivelyEmpty) {\r\n                 const parentStatementPath = suitePath.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement') {\r\n                     j(parentStatementPath).remove();\r\n                     console.log(`   - Describe/Context (línea ${suitePath.node.loc?.start?.line}) eliminado en archivo ${index + 1} por no contener bloques 'it'.`);\r\n                 } else {\r\n                     console.warn(`Advertencia: Describe/Context (línea ${suitePath.node.loc?.start?.line}) sin bloques 'it' no estaba en un ExpressionStatement directo y no se eliminó. Archivo ${index + 1}.`);\r\n                 }\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error(`Error durante la limpieza de bloques describe/context en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n    }\r\n    // --- FIN NUEVO PASO ---\r\n\r\n    // 5.1 --- NUEVO PASO: Desenvolver 'context' si solo contiene el bloque 'it' objetivo ---\r\n    try {\r\n        const contextCallPaths = astCopy.find(j.CallExpression, {\r\n            callee: { name: 'context' }\r\n        }).paths();\r\n\r\n        contextCallPaths.reverse().forEach(contextCallPath => {\r\n            const contextNode = contextCallPath.node;\r\n            if (!contextNode.arguments || contextNode.arguments.length < 2) return;\r\n\r\n            const contextCallback = contextNode.arguments[1];\r\n            if (!contextCallback || !contextCallback.body || contextCallback.body.type !== 'BlockStatement') return;\r\n\r\n            const contextBodyNode = contextCallback.body;\r\n            // Verificar que el cuerpo del context contenga exactamente una declaración\r\n            if (!contextBodyNode.body || contextBodyNode.body.length !== 1) {\r\n                return;\r\n            }\r\n\r\n            const singleStatementInContextBody = contextBodyNode.body[0];\r\n            // Verificar que la única declaración sea una ExpressionStatement que llama a 'it'\r\n            if (singleStatementInContextBody.type === 'ExpressionStatement' &&\r\n                singleStatementInContextBody.expression &&\r\n                singleStatementInContextBody.expression.type === 'CallExpression' &&\r\n                singleStatementInContextBody.expression.callee &&\r\n                singleStatementInContextBody.expression.callee.name === 'it') {\r\n\r\n                // Este 'context' contiene únicamente una llamada 'it'.\r\n                // Dado que otros 'it' fueron eliminados en el paso 4, este 'it' es el objetivo.\r\n                const contextStatementPath = contextCallPath.parentPath;\r\n                if (contextStatementPath.node.type === 'ExpressionStatement') {\r\n                    // Reemplazar el ExpressionStatement del 'context' con el ExpressionStatement del 'it'\r\n                    j(contextStatementPath).replaceWith(singleStatementInContextBody);\r\n                    console.log(`   - Contexto desenvuelto (línea ${contextNode.loc?.start?.line}) en archivo ${index + 1} porque solo contenía un bloque 'it'.`);\r\n                } else {\r\n                    console.warn(`Advertencia: Contexto (línea ${contextNode.loc?.start?.line}) que solo contenía un 'it' no estaba en un ExpressionStatement directo. No se desenvolvió en archivo ${index + 1}.`);\r\n                }\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error(`Error durante el desenvolvimiento de bloques 'context' en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n    }\r\n    // --- FIN NUEVO PASO 5.1 ---\r\n\r\n    // 6. Generar código fuente desde el AST modificado (ahora también sin describes vacíos)\r\n    const outputSource = astCopy.toSource({ quote: 'single', trailingComma: true });\r\n\r\n    // 7. Construir nuevo nombre de archivo y ruta de directorio de resultados\r\n    const resultsDir = path.join(dir, 'results'); // Directorio de resultados\r\n    \r\n    let newFileName;\r\n    if (baseName.endsWith('.spec')) {\r\n      const nameWithoutSpec = baseName.substring(0, baseName.length - '.spec'.length);\r\n      newFileName = `${nameWithoutSpec}${index + 1}.spec${ext}`;\r\n    } else {\r\n      // Fallback for other naming conventions if needed, or stick to original logic\r\n      // For now, let's assume files are *.spec.ext or handle as an error/warning\r\n      // Sticking to a modified version of original logic for non .spec files for broader compatibility\r\n      newFileName = `${baseName}${index + 1}${ext}`;\r\n      console.warn(`   Advertencia: El archivo base \"${baseName}${ext}\" no termina con '.spec'. Se usó el formato de nombre: ${newFileName}`);\r\n    }\r\n    // const newFileName = `${baseName}${index + 1}${ext}`; // Original line\r\n    const newFilePath = path.join(resultsDir, newFileName); // Ruta completa en 'results'\r\n\r\n    // 8. Asegurarse de que el directorio 'results' exista\r\n    try {\r\n        if (!fs.existsSync(resultsDir)) {\r\n            fs.mkdirSync(resultsDir, { recursive: true });\r\n            console.log(`   Directorio 'results' creado en: ${resultsDir}`);\r\n        }\r\n    } catch (error) {\r\n        console.error(`Error creando directorio ${resultsDir}:`, error);\r\n        return; // No continuar si no se puede crear el directorio\r\n    }\r\n\r\n\r\n    // 9. Escribir el nuevo archivo en el directorio 'results'\r\n    try {\r\n      fs.writeFileSync(newFilePath, outputSource);\r\n      console.log(`   Creado: ${newFilePath}`);\r\n    } catch (error) {\r\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\r\n    }\r\n  });\r\n\r\n  // Devolver undefined/null para no modificar el original\r\n  return undefined;\r\n}\r\n\r\n// export const parser = 'ts';"],"mappings":"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","ignoreList":[]}},"mtime":1746629971568},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\\\\split-specs-configurable.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformer;\nexports.parser = void 0;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n// split-specs-configurable.js - Modified transformer that accepts custom output folder\n\n// --- Helper Function ---\nconst locationsAreEqual = (locA, locB) => {\n  if (!locA || !locB) return false;\n  try {\n    return locA.start.line === locB.start.line && locA.start.column === locB.start.column && locA.end.line === locB.end.line && locA.end.column === locB.end.column;\n  } catch (e) {\n    console.error(\"Error comparando localizaciones:\", e);\n    return false;\n  }\n};\n// --- Fin Helper ---\n\nfunction transformer(fileInfo, api) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n  const itPaths = root.find(j.CallExpression, {\n    callee: {\n      name: 'it'\n    }\n  }).paths();\n  if (itPaths.length <= 1) {\n    return undefined;\n  }\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\n  const originalPath = fileInfo.path;\n  const dir = _path.default.dirname(originalPath);\n  const ext = _path.default.extname(originalPath);\n  const baseName = _path.default.basename(originalPath, ext);\n\n  // Use custom output folder if provided, otherwise default to 'results' subdirectory\n  const customOutputFolder = global.CUSTOM_OUTPUT_FOLDER;\n  const resultsDir = customOutputFolder || _path.default.join(dir, 'results');\n  itPaths.forEach((targetItPath, index) => {\n    // 1. Crear copia fresca del AST\n    const astCopy = j(fileInfo.source);\n\n    // 2. Encontrar todos los 'it' en la copia\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\n      callee: {\n        name: 'it'\n      }\n    }).paths();\n\n    // 3. Obtener la ubicación del 'it' a conservar\n    const targetLoc = targetItPath.node.loc;\n    if (!targetLoc) {\n      console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\n      return;\n    }\n\n    // 4. Eliminar los 'it' cuya ubicación NO COINCIDA\n    allItPathsInCopy.forEach(currentItPathInCopy => {\n      const currentLoc = currentItPathInCopy.node.loc;\n      if (!locationsAreEqual(currentLoc, targetLoc)) {\n        try {\n          var _parentStatementPath$;\n          const parentStatementPath = currentItPathInCopy.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement' && (_parentStatementPath$ = parentStatementPath.parentPath) !== null && _parentStatementPath$ !== void 0 && (_parentStatementPath$ = _parentStatementPath$.node) !== null && _parentStatementPath$ !== void 0 && _parentStatementPath$.type) {\n            j(parentStatementPath).remove();\n          } else {\n            var _currentLoc$start;\n            j(currentItPathInCopy).remove();\n            console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start = currentLoc.start) === null || _currentLoc$start === void 0 ? void 0 : _currentLoc$start.line}). Revise el archivo ${index + 1}.`);\n          }\n        } catch (error) {\n          var _currentLoc$start2;\n          console.error(`Error eliminando bloque 'it' (línea ${currentLoc === null || currentLoc === void 0 || (_currentLoc$start2 = currentLoc.start) === null || _currentLoc$start2 === void 0 ? void 0 : _currentLoc$start2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\n        }\n      }\n    });\n\n    // 5. --- NUEVO PASO: Eliminar bloques 'describe' o 'context' vacíos ---\n    try {\n      const suitePaths = astCopy.find(j.CallExpression).filter(path => path.node.callee.type === 'Identifier' && ['describe', 'context'].includes(path.node.callee.name)).paths();\n\n      // Iterar en REVERSA es importante al eliminar nodos para no afectar índices/paths\n      suitePaths.reverse().forEach(suitePath => {\n        let isEffectivelyEmpty = false;\n        try {\n          // Acceder al cuerpo (BlockStatement) de la función del describe/context\n          const suiteFunc = suitePath.node.arguments[1]; // El callback es usualmente el 2º argumento\n          let blockStatementNode;\n          if (suiteFunc && (suiteFunc.type === 'FunctionExpression' || suiteFunc.type === 'ArrowFunctionExpression') && suiteFunc.body.type === 'BlockStatement') {\n            blockStatementNode = suiteFunc.body;\n          } else {\n            var _suitePath$node$loc;\n            console.warn(`Advertencia: Estructura inesperada en describe/context (línea ${(_suitePath$node$loc = suitePath.node.loc) === null || _suitePath$node$loc === void 0 || (_suitePath$node$loc = _suitePath$node$loc.start) === null || _suitePath$node$loc === void 0 ? void 0 : _suitePath$node$loc.line}) en ${fileInfo.path} para archivo ${index + 1}. No se considerará para limpieza.`);\n            return; // Saltar al siguiente suitePath\n          }\n\n          // Comprobar si el cuerpo contiene llamadas 'it'\n          const itCallsInBlock = j(blockStatementNode).find(j.CallExpression, {\n            callee: {\n              name: 'it'\n            }\n          });\n          if (itCallsInBlock.length === 0) {\n            // No hay llamadas 'it' en este bloque describe/context.\n            isEffectivelyEmpty = true;\n          }\n        } catch (findError) {\n          var _suitePath$node$loc2;\n          console.error(`Error inspeccionando cuerpo de describe/context (línea ${(_suitePath$node$loc2 = suitePath.node.loc) === null || _suitePath$node$loc2 === void 0 || (_suitePath$node$loc2 = _suitePath$node$loc2.start) === null || _suitePath$node$loc2 === void 0 ? void 0 : _suitePath$node$loc2.line}) en ${fileInfo.path} para archivo ${index + 1}:`, findError);\n          isEffectivelyEmpty = false; // No eliminar si hubo error al inspeccionar\n        }\n        if (isEffectivelyEmpty) {\n          const parentStatementPath = suitePath.parentPath;\n          if (parentStatementPath.node.type === 'ExpressionStatement') {\n            var _suitePath$node$loc3;\n            j(parentStatementPath).remove();\n            console.log(`   - Describe/Context (línea ${(_suitePath$node$loc3 = suitePath.node.loc) === null || _suitePath$node$loc3 === void 0 || (_suitePath$node$loc3 = _suitePath$node$loc3.start) === null || _suitePath$node$loc3 === void 0 ? void 0 : _suitePath$node$loc3.line}) eliminado en archivo ${index + 1} por no contener bloques 'it'.`);\n          } else {\n            var _suitePath$node$loc4;\n            console.warn(`Advertencia: Describe/Context (línea ${(_suitePath$node$loc4 = suitePath.node.loc) === null || _suitePath$node$loc4 === void 0 || (_suitePath$node$loc4 = _suitePath$node$loc4.start) === null || _suitePath$node$loc4 === void 0 ? void 0 : _suitePath$node$loc4.line}) sin bloques 'it' no estaba en un ExpressionStatement directo y no se eliminó. Archivo ${index + 1}.`);\n          }\n        }\n      });\n    } catch (error) {\n      console.error(`Error durante la limpieza de bloques describe/context en ${fileInfo.path} para archivo ${index + 1}:`, error);\n    }\n    // --- FIN NUEVO PASO ---\n\n    // 5.1 --- NUEVO PASO: Desenvolver 'context' si solo contiene el bloque 'it' objetivo ---\n    try {\n      const contextCallPaths = astCopy.find(j.CallExpression, {\n        callee: {\n          name: 'context'\n        }\n      }).paths();\n      contextCallPaths.reverse().forEach(contextCallPath => {\n        const contextNode = contextCallPath.node;\n        if (!contextNode.arguments || contextNode.arguments.length < 2) return;\n        const contextCallback = contextNode.arguments[1];\n        if (!contextCallback || !contextCallback.body || contextCallback.body.type !== 'BlockStatement') return;\n        const contextBodyNode = contextCallback.body;\n        // Verificar que el cuerpo del context contenga exactamente una declaración\n        if (!contextBodyNode.body || contextBodyNode.body.length !== 1) {\n          return;\n        }\n        const singleStatementInContextBody = contextBodyNode.body[0];\n        // Verificar que la única declaración sea una ExpressionStatement que llama a 'it'\n        if (singleStatementInContextBody.type === 'ExpressionStatement' && singleStatementInContextBody.expression && singleStatementInContextBody.expression.type === 'CallExpression' && singleStatementInContextBody.expression.callee && singleStatementInContextBody.expression.callee.name === 'it') {\n          // Este 'context' contiene únicamente una llamada 'it'.\n          // Dado que otros 'it' fueron eliminados en el paso 4, este 'it' es el objetivo.\n          const contextStatementPath = contextCallPath.parentPath;\n          if (contextStatementPath.node.type === 'ExpressionStatement') {\n            var _contextNode$loc;\n            // Reemplazar el ExpressionStatement del 'context' con el ExpressionStatement del 'it'\n            j(contextStatementPath).replaceWith(singleStatementInContextBody);\n            console.log(`   - Contexto desenvuelto (línea ${(_contextNode$loc = contextNode.loc) === null || _contextNode$loc === void 0 || (_contextNode$loc = _contextNode$loc.start) === null || _contextNode$loc === void 0 ? void 0 : _contextNode$loc.line}) en archivo ${index + 1} porque solo contenía un bloque 'it'.`);\n          } else {\n            var _contextNode$loc2;\n            console.warn(`Advertencia: Contexto (línea ${(_contextNode$loc2 = contextNode.loc) === null || _contextNode$loc2 === void 0 || (_contextNode$loc2 = _contextNode$loc2.start) === null || _contextNode$loc2 === void 0 ? void 0 : _contextNode$loc2.line}) que solo contenía un 'it' no estaba en un ExpressionStatement directo. No se desenvolvió en archivo ${index + 1}.`);\n          }\n        }\n      });\n    } catch (error) {\n      console.error(`Error durante el desenvolvimiento de bloques 'context' en ${fileInfo.path} para archivo ${index + 1}:`, error);\n    }\n    // --- FIN NUEVO PASO 5.1 ---\n\n    // 6. Generar código fuente desde el AST modificado (ahora también sin describes vacíos)\n    const outputSource = astCopy.toSource({\n      quote: 'single',\n      trailingComma: true\n    });\n\n    // 7. Construir nuevo nombre de archivo y ruta de directorio de resultados\n    let newFileName;\n    if (baseName.endsWith('.spec')) {\n      const nameWithoutSpec = baseName.substring(0, baseName.length - '.spec'.length);\n      newFileName = `${nameWithoutSpec}${index + 1}.spec${ext}`;\n    } else {\n      // Fallback for other naming conventions if needed, or stick to original logic\n      // For now, let's assume files are *.spec.ext or handle as an error/warning\n      // Sticking to a modified version of original logic for non .spec files for broader compatibility\n      newFileName = `${baseName}${index + 1}${ext}`;\n      console.warn(`   Advertencia: El archivo base \"${baseName}${ext}\" no termina con '.spec'. Se usó el formato de nombre: ${newFileName}`);\n    }\n    const newFilePath = _path.default.join(resultsDir, newFileName); // Ruta completa usando resultsDir configurable\n\n    // 8. Asegurarse de que el directorio de salida exista\n    try {\n      if (!_fs.default.existsSync(resultsDir)) {\n        _fs.default.mkdirSync(resultsDir, {\n          recursive: true\n        });\n        if (customOutputFolder) {\n          console.log(`   Directorio de salida personalizado creado en: ${resultsDir}`);\n        } else {\n          console.log(`   Directorio 'results' creado en: ${resultsDir}`);\n        }\n      }\n    } catch (error) {\n      console.error(`Error creando directorio ${resultsDir}:`, error);\n      return; // No continuar si no se puede crear el directorio\n    }\n\n    // 9. Escribir el nuevo archivo en el directorio de salida\n    try {\n      _fs.default.writeFileSync(newFilePath, outputSource);\n      console.log(`   Creado: ${newFilePath}`);\n    } catch (error) {\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\n    }\n  });\n\n  // Devolver undefined/null para no modificar el original\n  return undefined;\n}\nconst parser = exports.parser = 'tsx';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZnMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9wYXRoIiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwibG9jYXRpb25zQXJlRXF1YWwiLCJsb2NBIiwibG9jQiIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsImVuZCIsImNvbnNvbGUiLCJlcnJvciIsInRyYW5zZm9ybWVyIiwiZmlsZUluZm8iLCJhcGkiLCJqIiwianNjb2Rlc2hpZnQiLCJyb290Iiwic291cmNlIiwiaXRQYXRocyIsImZpbmQiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsIm5hbWUiLCJwYXRocyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImxvZyIsInBhdGgiLCJvcmlnaW5hbFBhdGgiLCJkaXIiLCJkaXJuYW1lIiwiZXh0IiwiZXh0bmFtZSIsImJhc2VOYW1lIiwiYmFzZW5hbWUiLCJjdXN0b21PdXRwdXRGb2xkZXIiLCJnbG9iYWwiLCJDVVNUT01fT1VUUFVUX0ZPTERFUiIsInJlc3VsdHNEaXIiLCJqb2luIiwiZm9yRWFjaCIsInRhcmdldEl0UGF0aCIsImluZGV4IiwiYXN0Q29weSIsImFsbEl0UGF0aHNJbkNvcHkiLCJ0YXJnZXRMb2MiLCJub2RlIiwibG9jIiwiY3VycmVudEl0UGF0aEluQ29weSIsImN1cnJlbnRMb2MiLCJfcGFyZW50U3RhdGVtZW50UGF0aCQiLCJwYXJlbnRTdGF0ZW1lbnRQYXRoIiwicGFyZW50UGF0aCIsInR5cGUiLCJyZW1vdmUiLCJfY3VycmVudExvYyRzdGFydCIsIndhcm4iLCJfY3VycmVudExvYyRzdGFydDIiLCJzdWl0ZVBhdGhzIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJyZXZlcnNlIiwic3VpdGVQYXRoIiwiaXNFZmZlY3RpdmVseUVtcHR5Iiwic3VpdGVGdW5jIiwiYXJndW1lbnRzIiwiYmxvY2tTdGF0ZW1lbnROb2RlIiwiYm9keSIsIl9zdWl0ZVBhdGgkbm9kZSRsb2MiLCJpdENhbGxzSW5CbG9jayIsImZpbmRFcnJvciIsIl9zdWl0ZVBhdGgkbm9kZSRsb2MyIiwiX3N1aXRlUGF0aCRub2RlJGxvYzMiLCJfc3VpdGVQYXRoJG5vZGUkbG9jNCIsImNvbnRleHRDYWxsUGF0aHMiLCJjb250ZXh0Q2FsbFBhdGgiLCJjb250ZXh0Tm9kZSIsImNvbnRleHRDYWxsYmFjayIsImNvbnRleHRCb2R5Tm9kZSIsInNpbmdsZVN0YXRlbWVudEluQ29udGV4dEJvZHkiLCJleHByZXNzaW9uIiwiY29udGV4dFN0YXRlbWVudFBhdGgiLCJfY29udGV4dE5vZGUkbG9jIiwicmVwbGFjZVdpdGgiLCJfY29udGV4dE5vZGUkbG9jMiIsIm91dHB1dFNvdXJjZSIsInRvU291cmNlIiwicXVvdGUiLCJ0cmFpbGluZ0NvbW1hIiwibmV3RmlsZU5hbWUiLCJlbmRzV2l0aCIsIm5hbWVXaXRob3V0U3BlYyIsInN1YnN0cmluZyIsIm5ld0ZpbGVQYXRoIiwiZnMiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwid3JpdGVGaWxlU3luYyIsInBhcnNlciIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IkM6XFxVc2Vyc1xceGFiaWFcXE9uZURyaXZlXFxEb2N1bWVudG9zXFw0Lk1haWxhXFxURkctQmVzdGVsYWtvYWtcXEJlc3RlbGFrb2FrXFxQcm9pZWt0dWFcXHNwbGl0SVRKQ29kZVNoaWZ0XFwiLCJzb3VyY2VzIjpbInNwbGl0LXNwZWNzLWNvbmZpZ3VyYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcGxpdC1zcGVjcy1jb25maWd1cmFibGUuanMgLSBNb2RpZmllZCB0cmFuc2Zvcm1lciB0aGF0IGFjY2VwdHMgY3VzdG9tIG91dHB1dCBmb2xkZXJcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG4vLyAtLS0gSGVscGVyIEZ1bmN0aW9uIC0tLVxyXG5jb25zdCBsb2NhdGlvbnNBcmVFcXVhbCA9IChsb2NBLCBsb2NCKSA9PiB7XHJcbiAgICBpZiAoIWxvY0EgfHwgIWxvY0IpIHJldHVybiBmYWxzZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgbG9jQS5zdGFydC5saW5lID09PSBsb2NCLnN0YXJ0LmxpbmUgJiZcclxuICAgICAgICAgICAgbG9jQS5zdGFydC5jb2x1bW4gPT09IGxvY0Iuc3RhcnQuY29sdW1uICYmXHJcbiAgICAgICAgICAgIGxvY0EuZW5kLmxpbmUgPT09IGxvY0IuZW5kLmxpbmUgJiZcclxuICAgICAgICAgICAgbG9jQS5lbmQuY29sdW1uID09PSBsb2NCLmVuZC5jb2x1bW5cclxuICAgICAgICApO1xyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbXBhcmFuZG8gbG9jYWxpemFjaW9uZXM6XCIsIGUpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuLy8gLS0tIEZpbiBIZWxwZXIgLS0tXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1lcihmaWxlSW5mbywgYXBpKSB7XHJcbiAgY29uc3QgaiA9IGFwaS5qc2NvZGVzaGlmdDtcclxuICBjb25zdCByb290ID0gaihmaWxlSW5mby5zb3VyY2UpO1xyXG5cclxuICBjb25zdCBpdFBhdGhzID0gcm9vdC5maW5kKGouQ2FsbEV4cHJlc3Npb24sIHtcclxuICAgIGNhbGxlZTogeyBuYW1lOiAnaXQnIH0sXHJcbiAgfSkucGF0aHMoKTtcclxuXHJcbiAgaWYgKGl0UGF0aHMubGVuZ3RoIDw9IDEpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhgLT4gQXJjaGl2byAke2ZpbGVJbmZvLnBhdGh9OiAke2l0UGF0aHMubGVuZ3RofSBibG9xdWUocykgJ2l0JyBlbmNvbnRyYWRvcy4gR2VuZXJhbmRvIGFyY2hpdm9zIGluZGl2aWR1YWxlcy4uLmApO1xyXG5cclxuICBjb25zdCBvcmlnaW5hbFBhdGggPSBmaWxlSW5mby5wYXRoO1xyXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShvcmlnaW5hbFBhdGgpO1xyXG4gIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZShvcmlnaW5hbFBhdGgpO1xyXG4gIGNvbnN0IGJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShvcmlnaW5hbFBhdGgsIGV4dCk7XHJcblxyXG4gIC8vIFVzZSBjdXN0b20gb3V0cHV0IGZvbGRlciBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gJ3Jlc3VsdHMnIHN1YmRpcmVjdG9yeVxyXG4gIGNvbnN0IGN1c3RvbU91dHB1dEZvbGRlciA9IGdsb2JhbC5DVVNUT01fT1VUUFVUX0ZPTERFUjtcclxuICBjb25zdCByZXN1bHRzRGlyID0gY3VzdG9tT3V0cHV0Rm9sZGVyIHx8IHBhdGguam9pbihkaXIsICdyZXN1bHRzJyk7XHJcblxyXG4gIGl0UGF0aHMuZm9yRWFjaCgodGFyZ2V0SXRQYXRoLCBpbmRleCkgPT4ge1xyXG4gICAgLy8gMS4gQ3JlYXIgY29waWEgZnJlc2NhIGRlbCBBU1RcclxuICAgIGNvbnN0IGFzdENvcHkgPSBqKGZpbGVJbmZvLnNvdXJjZSk7XHJcblxyXG4gICAgLy8gMi4gRW5jb250cmFyIHRvZG9zIGxvcyAnaXQnIGVuIGxhIGNvcGlhXHJcbiAgICBjb25zdCBhbGxJdFBhdGhzSW5Db3B5ID0gYXN0Q29weS5maW5kKGouQ2FsbEV4cHJlc3Npb24sIHtcclxuICAgICAgICBjYWxsZWU6IHsgbmFtZTogJ2l0JyB9LFxyXG4gICAgICB9KS5wYXRocygpO1xyXG5cclxuICAgIC8vIDMuIE9idGVuZXIgbGEgdWJpY2FjacOzbiBkZWwgJ2l0JyBhIGNvbnNlcnZhclxyXG4gICAgY29uc3QgdGFyZ2V0TG9jID0gdGFyZ2V0SXRQYXRoLm5vZGUubG9jO1xyXG4gICAgaWYgKCF0YXJnZXRMb2MpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBDcsOtdGljbzogRmFsdGEgaW5mb3JtYWNpw7NuIGRlIHViaWNhY2nDs24gcGFyYSBlbCBibG9xdWUgJ2l0JyAow61uZGljZSAke2luZGV4fSkgZW4gJHtmaWxlSW5mby5wYXRofS4gTm8gc2UgcHVlZGUgZ2VuZXJhciBhcmNoaXZvICR7aW5kZXggKyAxfS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNC4gRWxpbWluYXIgbG9zICdpdCcgY3V5YSB1YmljYWNpw7NuIE5PIENPSU5DSURBXHJcbiAgICBhbGxJdFBhdGhzSW5Db3B5LmZvckVhY2goY3VycmVudEl0UGF0aEluQ29weSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudExvYyA9IGN1cnJlbnRJdFBhdGhJbkNvcHkubm9kZS5sb2M7XHJcbiAgICAgICAgaWYgKCFsb2NhdGlvbnNBcmVFcXVhbChjdXJyZW50TG9jLCB0YXJnZXRMb2MpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U3RhdGVtZW50UGF0aCA9IGN1cnJlbnRJdFBhdGhJbkNvcHkucGFyZW50UGF0aDtcclxuICAgICAgICAgICAgICAgICBpZiAocGFyZW50U3RhdGVtZW50UGF0aC5ub2RlLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyAmJiBwYXJlbnRTdGF0ZW1lbnRQYXRoLnBhcmVudFBhdGg/Lm5vZGU/LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgaihwYXJlbnRTdGF0ZW1lbnRQYXRoKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBqKGN1cnJlbnRJdFBhdGhJbkNvcHkpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFkdmVydGVuY2lhOiBFc3RydWN0dXJhIGluZXNwZXJhZGEgcGFyYSBibG9xdWUgJ2l0JyBlbiAke2ZpbGVJbmZvLnBhdGh9IChsw61uZWEgJHtjdXJyZW50TG9jPy5zdGFydD8ubGluZX0pLiBSZXZpc2UgZWwgYXJjaGl2byAke2luZGV4ICsgMX0uYCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZWxpbWluYW5kbyBibG9xdWUgJ2l0JyAobMOtbmVhICR7Y3VycmVudExvYz8uc3RhcnQ/LmxpbmV9KSBlbiAke2ZpbGVJbmZvLnBhdGh9IHBhcmEgYXJjaGl2byAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gNS4gLS0tIE5VRVZPIFBBU086IEVsaW1pbmFyIGJsb3F1ZXMgJ2Rlc2NyaWJlJyBvICdjb250ZXh0JyB2YWPDrW9zIC0tLVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBzdWl0ZVBhdGhzID0gYXN0Q29weS5maW5kKGouQ2FsbEV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgIC5maWx0ZXIocGF0aCA9PlxyXG4gICAgICAgICAgICAgICAgcGF0aC5ub2RlLmNhbGxlZS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcclxuICAgICAgICAgICAgICAgIFsnZGVzY3JpYmUnLCAnY29udGV4dCddLmluY2x1ZGVzKHBhdGgubm9kZS5jYWxsZWUubmFtZSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAucGF0aHMoKTtcclxuXHJcbiAgICAgICAgLy8gSXRlcmFyIGVuIFJFVkVSU0EgZXMgaW1wb3J0YW50ZSBhbCBlbGltaW5hciBub2RvcyBwYXJhIG5vIGFmZWN0YXIgw61uZGljZXMvcGF0aHNcclxuICAgICAgICBzdWl0ZVBhdGhzLnJldmVyc2UoKS5mb3JFYWNoKHN1aXRlUGF0aCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpc0VmZmVjdGl2ZWx5RW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEFjY2VkZXIgYWwgY3VlcnBvIChCbG9ja1N0YXRlbWVudCkgZGUgbGEgZnVuY2nDs24gZGVsIGRlc2NyaWJlL2NvbnRleHRcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1aXRlRnVuYyA9IHN1aXRlUGF0aC5ub2RlLmFyZ3VtZW50c1sxXTsgLy8gRWwgY2FsbGJhY2sgZXMgdXN1YWxtZW50ZSBlbCAywrogYXJndW1lbnRvXHJcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tTdGF0ZW1lbnROb2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdWl0ZUZ1bmMgJiYgKHN1aXRlRnVuYy50eXBlID09PSAnRnVuY3Rpb25FeHByZXNzaW9uJyB8fCBzdWl0ZUZ1bmMudHlwZSA9PT0gJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJykgJiYgc3VpdGVGdW5jLmJvZHkudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICBibG9ja1N0YXRlbWVudE5vZGUgPSBzdWl0ZUZ1bmMuYm9keTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQWR2ZXJ0ZW5jaWE6IEVzdHJ1Y3R1cmEgaW5lc3BlcmFkYSBlbiBkZXNjcmliZS9jb250ZXh0IChsw61uZWEgJHtzdWl0ZVBhdGgubm9kZS5sb2M/LnN0YXJ0Py5saW5lfSkgZW4gJHtmaWxlSW5mby5wYXRofSBwYXJhIGFyY2hpdm8gJHtpbmRleCArIDF9LiBObyBzZSBjb25zaWRlcmFyw6EgcGFyYSBsaW1waWV6YS5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTYWx0YXIgYWwgc2lndWllbnRlIHN1aXRlUGF0aFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXByb2JhciBzaSBlbCBjdWVycG8gY29udGllbmUgbGxhbWFkYXMgJ2l0J1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXRDYWxsc0luQmxvY2sgPSBqKGJsb2NrU3RhdGVtZW50Tm9kZSkuZmluZChqLkNhbGxFeHByZXNzaW9uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiB7IG5hbWU6ICdpdCcgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGl0Q2FsbHNJbkJsb2NrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGhheSBsbGFtYWRhcyAnaXQnIGVuIGVzdGUgYmxvcXVlIGRlc2NyaWJlL2NvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFZmZlY3RpdmVseUVtcHR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGZpbmRFcnJvcil7XHJcbiAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW5zcGVjY2lvbmFuZG8gY3VlcnBvIGRlIGRlc2NyaWJlL2NvbnRleHQgKGzDrW5lYSAke3N1aXRlUGF0aC5ub2RlLmxvYz8uc3RhcnQ/LmxpbmV9KSBlbiAke2ZpbGVJbmZvLnBhdGh9IHBhcmEgYXJjaGl2byAke2luZGV4ICsgMX06YCwgZmluZEVycm9yKTtcclxuICAgICAgICAgICAgICAgICBpc0VmZmVjdGl2ZWx5RW1wdHkgPSBmYWxzZTsgLy8gTm8gZWxpbWluYXIgc2kgaHVibyBlcnJvciBhbCBpbnNwZWNjaW9uYXJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzRWZmZWN0aXZlbHlFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0YXRlbWVudFBhdGggPSBzdWl0ZVBhdGgucGFyZW50UGF0aDtcclxuICAgICAgICAgICAgICAgICBpZiAocGFyZW50U3RhdGVtZW50UGF0aC5ub2RlLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICBqKHBhcmVudFN0YXRlbWVudFBhdGgpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgLSBEZXNjcmliZS9Db250ZXh0IChsw61uZWEgJHtzdWl0ZVBhdGgubm9kZS5sb2M/LnN0YXJ0Py5saW5lfSkgZWxpbWluYWRvIGVuIGFyY2hpdm8gJHtpbmRleCArIDF9IHBvciBubyBjb250ZW5lciBibG9xdWVzICdpdCcuYCk7XHJcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBZHZlcnRlbmNpYTogRGVzY3JpYmUvQ29udGV4dCAobMOtbmVhICR7c3VpdGVQYXRoLm5vZGUubG9jPy5zdGFydD8ubGluZX0pIHNpbiBibG9xdWVzICdpdCcgbm8gZXN0YWJhIGVuIHVuIEV4cHJlc3Npb25TdGF0ZW1lbnQgZGlyZWN0byB5IG5vIHNlIGVsaW1pbsOzLiBBcmNoaXZvICR7aW5kZXggKyAxfS5gKTtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZHVyYW50ZSBsYSBsaW1waWV6YSBkZSBibG9xdWVzIGRlc2NyaWJlL2NvbnRleHQgZW4gJHtmaWxlSW5mby5wYXRofSBwYXJhIGFyY2hpdm8gJHtpbmRleCArIDF9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICAgIC8vIC0tLSBGSU4gTlVFVk8gUEFTTyAtLS1cclxuXHJcbiAgICAvLyA1LjEgLS0tIE5VRVZPIFBBU086IERlc2Vudm9sdmVyICdjb250ZXh0JyBzaSBzb2xvIGNvbnRpZW5lIGVsIGJsb3F1ZSAnaXQnIG9iamV0aXZvIC0tLVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjb250ZXh0Q2FsbFBhdGhzID0gYXN0Q29weS5maW5kKGouQ2FsbEV4cHJlc3Npb24sIHtcclxuICAgICAgICAgICAgY2FsbGVlOiB7IG5hbWU6ICdjb250ZXh0JyB9XHJcbiAgICAgICAgfSkucGF0aHMoKTtcclxuXHJcbiAgICAgICAgY29udGV4dENhbGxQYXRocy5yZXZlcnNlKCkuZm9yRWFjaChjb250ZXh0Q2FsbFBhdGggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0Tm9kZSA9IGNvbnRleHRDYWxsUGF0aC5ub2RlO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHROb2RlLmFyZ3VtZW50cyB8fCBjb250ZXh0Tm9kZS5hcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGV4dENhbGxiYWNrID0gY29udGV4dE5vZGUuYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHRDYWxsYmFjayB8fCAhY29udGV4dENhbGxiYWNrLmJvZHkgfHwgY29udGV4dENhbGxiYWNrLmJvZHkudHlwZSAhPT0gJ0Jsb2NrU3RhdGVtZW50JykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGV4dEJvZHlOb2RlID0gY29udGV4dENhbGxiYWNrLmJvZHk7XHJcbiAgICAgICAgICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgY3VlcnBvIGRlbCBjb250ZXh0IGNvbnRlbmdhIGV4YWN0YW1lbnRlIHVuYSBkZWNsYXJhY2nDs25cclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0Qm9keU5vZGUuYm9keSB8fCBjb250ZXh0Qm9keU5vZGUuYm9keS5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3Qgc2luZ2xlU3RhdGVtZW50SW5Db250ZXh0Qm9keSA9IGNvbnRleHRCb2R5Tm9kZS5ib2R5WzBdO1xyXG4gICAgICAgICAgICAvLyBWZXJpZmljYXIgcXVlIGxhIMO6bmljYSBkZWNsYXJhY2nDs24gc2VhIHVuYSBFeHByZXNzaW9uU3RhdGVtZW50IHF1ZSBsbGFtYSBhICdpdCdcclxuICAgICAgICAgICAgaWYgKHNpbmdsZVN0YXRlbWVudEluQ29udGV4dEJvZHkudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICYmXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVTdGF0ZW1lbnRJbkNvbnRleHRCb2R5LmV4cHJlc3Npb24gJiZcclxuICAgICAgICAgICAgICAgIHNpbmdsZVN0YXRlbWVudEluQ29udGV4dEJvZHkuZXhwcmVzc2lvbi50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nICYmXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVTdGF0ZW1lbnRJbkNvbnRleHRCb2R5LmV4cHJlc3Npb24uY2FsbGVlICYmXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVTdGF0ZW1lbnRJbkNvbnRleHRCb2R5LmV4cHJlc3Npb24uY2FsbGVlLm5hbWUgPT09ICdpdCcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFc3RlICdjb250ZXh0JyBjb250aWVuZSDDum5pY2FtZW50ZSB1bmEgbGxhbWFkYSAnaXQnLlxyXG4gICAgICAgICAgICAgICAgLy8gRGFkbyBxdWUgb3Ryb3MgJ2l0JyBmdWVyb24gZWxpbWluYWRvcyBlbiBlbCBwYXNvIDQsIGVzdGUgJ2l0JyBlcyBlbCBvYmpldGl2by5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRTdGF0ZW1lbnRQYXRoID0gY29udGV4dENhbGxQYXRoLnBhcmVudFBhdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dFN0YXRlbWVudFBhdGgubm9kZS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWVtcGxhemFyIGVsIEV4cHJlc3Npb25TdGF0ZW1lbnQgZGVsICdjb250ZXh0JyBjb24gZWwgRXhwcmVzc2lvblN0YXRlbWVudCBkZWwgJ2l0J1xyXG4gICAgICAgICAgICAgICAgICAgIGooY29udGV4dFN0YXRlbWVudFBhdGgpLnJlcGxhY2VXaXRoKHNpbmdsZVN0YXRlbWVudEluQ29udGV4dEJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAtIENvbnRleHRvIGRlc2VudnVlbHRvIChsw61uZWEgJHtjb250ZXh0Tm9kZS5sb2M/LnN0YXJ0Py5saW5lfSkgZW4gYXJjaGl2byAke2luZGV4ICsgMX0gcG9ycXVlIHNvbG8gY29udGVuw61hIHVuIGJsb3F1ZSAnaXQnLmApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFkdmVydGVuY2lhOiBDb250ZXh0byAobMOtbmVhICR7Y29udGV4dE5vZGUubG9jPy5zdGFydD8ubGluZX0pIHF1ZSBzb2xvIGNvbnRlbsOtYSB1biAnaXQnIG5vIGVzdGFiYSBlbiB1biBFeHByZXNzaW9uU3RhdGVtZW50IGRpcmVjdG8uIE5vIHNlIGRlc2Vudm9sdmnDsyBlbiBhcmNoaXZvICR7aW5kZXggKyAxfS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkdXJhbnRlIGVsIGRlc2Vudm9sdmltaWVudG8gZGUgYmxvcXVlcyAnY29udGV4dCcgZW4gJHtmaWxlSW5mby5wYXRofSBwYXJhIGFyY2hpdm8gJHtpbmRleCArIDF9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICAgIC8vIC0tLSBGSU4gTlVFVk8gUEFTTyA1LjEgLS0tXHJcblxyXG4gICAgLy8gNi4gR2VuZXJhciBjw7NkaWdvIGZ1ZW50ZSBkZXNkZSBlbCBBU1QgbW9kaWZpY2FkbyAoYWhvcmEgdGFtYmnDqW4gc2luIGRlc2NyaWJlcyB2YWPDrW9zKVxyXG4gICAgY29uc3Qgb3V0cHV0U291cmNlID0gYXN0Q29weS50b1NvdXJjZSh7IHF1b3RlOiAnc2luZ2xlJywgdHJhaWxpbmdDb21tYTogdHJ1ZSB9KTtcclxuXHJcbiAgICAvLyA3LiBDb25zdHJ1aXIgbnVldm8gbm9tYnJlIGRlIGFyY2hpdm8geSBydXRhIGRlIGRpcmVjdG9yaW8gZGUgcmVzdWx0YWRvc1xyXG4gICAgbGV0IG5ld0ZpbGVOYW1lO1xyXG4gICAgaWYgKGJhc2VOYW1lLmVuZHNXaXRoKCcuc3BlYycpKSB7XHJcbiAgICAgIGNvbnN0IG5hbWVXaXRob3V0U3BlYyA9IGJhc2VOYW1lLnN1YnN0cmluZygwLCBiYXNlTmFtZS5sZW5ndGggLSAnLnNwZWMnLmxlbmd0aCk7XHJcbiAgICAgIG5ld0ZpbGVOYW1lID0gYCR7bmFtZVdpdGhvdXRTcGVjfSR7aW5kZXggKyAxfS5zcGVjJHtleHR9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEZhbGxiYWNrIGZvciBvdGhlciBuYW1pbmcgY29udmVudGlvbnMgaWYgbmVlZGVkLCBvciBzdGljayB0byBvcmlnaW5hbCBsb2dpY1xyXG4gICAgICAvLyBGb3Igbm93LCBsZXQncyBhc3N1bWUgZmlsZXMgYXJlICouc3BlYy5leHQgb3IgaGFuZGxlIGFzIGFuIGVycm9yL3dhcm5pbmdcclxuICAgICAgLy8gU3RpY2tpbmcgdG8gYSBtb2RpZmllZCB2ZXJzaW9uIG9mIG9yaWdpbmFsIGxvZ2ljIGZvciBub24gLnNwZWMgZmlsZXMgZm9yIGJyb2FkZXIgY29tcGF0aWJpbGl0eVxyXG4gICAgICBuZXdGaWxlTmFtZSA9IGAke2Jhc2VOYW1lfSR7aW5kZXggKyAxfSR7ZXh0fWA7XHJcbiAgICAgIGNvbnNvbGUud2FybihgICAgQWR2ZXJ0ZW5jaWE6IEVsIGFyY2hpdm8gYmFzZSBcIiR7YmFzZU5hbWV9JHtleHR9XCIgbm8gdGVybWluYSBjb24gJy5zcGVjJy4gU2UgdXPDsyBlbCBmb3JtYXRvIGRlIG5vbWJyZTogJHtuZXdGaWxlTmFtZX1gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0ZpbGVQYXRoID0gcGF0aC5qb2luKHJlc3VsdHNEaXIsIG5ld0ZpbGVOYW1lKTsgLy8gUnV0YSBjb21wbGV0YSB1c2FuZG8gcmVzdWx0c0RpciBjb25maWd1cmFibGVcclxuXHJcbiAgICAvLyA4LiBBc2VndXJhcnNlIGRlIHF1ZSBlbCBkaXJlY3RvcmlvIGRlIHNhbGlkYSBleGlzdGFcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHJlc3VsdHNEaXIpKSB7XHJcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhyZXN1bHRzRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgaWYgKGN1c3RvbU91dHB1dEZvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIERpcmVjdG9yaW8gZGUgc2FsaWRhIHBlcnNvbmFsaXphZG8gY3JlYWRvIGVuOiAke3Jlc3VsdHNEaXJ9YCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgRGlyZWN0b3JpbyAncmVzdWx0cycgY3JlYWRvIGVuOiAke3Jlc3VsdHNEaXJ9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNyZWFuZG8gZGlyZWN0b3JpbyAke3Jlc3VsdHNEaXJ9OmAsIGVycm9yKTtcclxuICAgICAgICByZXR1cm47IC8vIE5vIGNvbnRpbnVhciBzaSBubyBzZSBwdWVkZSBjcmVhciBlbCBkaXJlY3RvcmlvXHJcbiAgICB9XHJcblxyXG4gICAgLy8gOS4gRXNjcmliaXIgZWwgbnVldm8gYXJjaGl2byBlbiBlbCBkaXJlY3RvcmlvIGRlIHNhbGlkYVxyXG4gICAgdHJ5IHtcclxuICAgICAgZnMud3JpdGVGaWxlU3luYyhuZXdGaWxlUGF0aCwgb3V0cHV0U291cmNlKTtcclxuICAgICAgY29uc29sZS5sb2coYCAgIENyZWFkbzogJHtuZXdGaWxlUGF0aH1gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVzY3JpYmllbmRvIGFyY2hpdm8gJHtuZXdGaWxlUGF0aH06YCwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBEZXZvbHZlciB1bmRlZmluZWQvbnVsbCBwYXJhIG5vIG1vZGlmaWNhciBlbCBvcmlnaW5hbFxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZXIgPSAndHN4JztcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0EsSUFBQUEsR0FBQSxHQUFBQyxzQkFBQSxDQUFBQyxPQUFBO0FBQ0EsSUFBQUMsS0FBQSxHQUFBRixzQkFBQSxDQUFBQyxPQUFBO0FBQXdCLFNBQUFELHVCQUFBRyxDQUFBLFdBQUFBLENBQUEsSUFBQUEsQ0FBQSxDQUFBQyxVQUFBLEdBQUFELENBQUEsS0FBQUUsT0FBQSxFQUFBRixDQUFBO0FBRnhCOztBQUlBO0FBQ0EsTUFBTUcsaUJBQWlCLEdBQUdBLENBQUNDLElBQUksRUFBRUMsSUFBSSxLQUFLO0VBQ3RDLElBQUksQ0FBQ0QsSUFBSSxJQUFJLENBQUNDLElBQUksRUFBRSxPQUFPLEtBQUs7RUFDaEMsSUFBSTtJQUNBLE9BQ0lELElBQUksQ0FBQ0UsS0FBSyxDQUFDQyxJQUFJLEtBQUtGLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLElBQ25DSCxJQUFJLENBQUNFLEtBQUssQ0FBQ0UsTUFBTSxLQUFLSCxJQUFJLENBQUNDLEtBQUssQ0FBQ0UsTUFBTSxJQUN2Q0osSUFBSSxDQUFDSyxHQUFHLENBQUNGLElBQUksS0FBS0YsSUFBSSxDQUFDSSxHQUFHLENBQUNGLElBQUksSUFDL0JILElBQUksQ0FBQ0ssR0FBRyxDQUFDRCxNQUFNLEtBQUtILElBQUksQ0FBQ0ksR0FBRyxDQUFDRCxNQUFNO0VBRTNDLENBQUMsQ0FBQyxPQUFNUixDQUFDLEVBQUU7SUFDUFUsT0FBTyxDQUFDQyxLQUFLLENBQUMsa0NBQWtDLEVBQUVYLENBQUMsQ0FBQztJQUNwRCxPQUFPLEtBQUs7RUFDaEI7QUFDSixDQUFDO0FBQ0Q7O0FBRWUsU0FBU1ksV0FBV0EsQ0FBQ0MsUUFBUSxFQUFFQyxHQUFHLEVBQUU7RUFDakQsTUFBTUMsQ0FBQyxHQUFHRCxHQUFHLENBQUNFLFdBQVc7RUFDekIsTUFBTUMsSUFBSSxHQUFHRixDQUFDLENBQUNGLFFBQVEsQ0FBQ0ssTUFBTSxDQUFDO0VBRS9CLE1BQU1DLE9BQU8sR0FBR0YsSUFBSSxDQUFDRyxJQUFJLENBQUNMLENBQUMsQ0FBQ00sY0FBYyxFQUFFO0lBQzFDQyxNQUFNLEVBQUU7TUFBRUMsSUFBSSxFQUFFO0lBQUs7RUFDdkIsQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQyxDQUFDO0VBRVYsSUFBSUwsT0FBTyxDQUFDTSxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQ3ZCLE9BQU9DLFNBQVM7RUFDbEI7RUFFQWhCLE9BQU8sQ0FBQ2lCLEdBQUcsQ0FBQyxjQUFjZCxRQUFRLENBQUNlLElBQUksS0FBS1QsT0FBTyxDQUFDTSxNQUFNLGlFQUFpRSxDQUFDO0VBRTVILE1BQU1JLFlBQVksR0FBR2hCLFFBQVEsQ0FBQ2UsSUFBSTtFQUNsQyxNQUFNRSxHQUFHLEdBQUdGLGFBQUksQ0FBQ0csT0FBTyxDQUFDRixZQUFZLENBQUM7RUFDdEMsTUFBTUcsR0FBRyxHQUFHSixhQUFJLENBQUNLLE9BQU8sQ0FBQ0osWUFBWSxDQUFDO0VBQ3RDLE1BQU1LLFFBQVEsR0FBR04sYUFBSSxDQUFDTyxRQUFRLENBQUNOLFlBQVksRUFBRUcsR0FBRyxDQUFDOztFQUVqRDtFQUNBLE1BQU1JLGtCQUFrQixHQUFHQyxNQUFNLENBQUNDLG9CQUFvQjtFQUN0RCxNQUFNQyxVQUFVLEdBQUdILGtCQUFrQixJQUFJUixhQUFJLENBQUNZLElBQUksQ0FBQ1YsR0FBRyxFQUFFLFNBQVMsQ0FBQztFQUVsRVgsT0FBTyxDQUFDc0IsT0FBTyxDQUFDLENBQUNDLFlBQVksRUFBRUMsS0FBSyxLQUFLO0lBQ3ZDO0lBQ0EsTUFBTUMsT0FBTyxHQUFHN0IsQ0FBQyxDQUFDRixRQUFRLENBQUNLLE1BQU0sQ0FBQzs7SUFFbEM7SUFDQSxNQUFNMkIsZ0JBQWdCLEdBQUdELE9BQU8sQ0FBQ3hCLElBQUksQ0FBQ0wsQ0FBQyxDQUFDTSxjQUFjLEVBQUU7TUFDcERDLE1BQU0sRUFBRTtRQUFFQyxJQUFJLEVBQUU7TUFBSztJQUN2QixDQUFDLENBQUMsQ0FBQ0MsS0FBSyxDQUFDLENBQUM7O0lBRVo7SUFDQSxNQUFNc0IsU0FBUyxHQUFHSixZQUFZLENBQUNLLElBQUksQ0FBQ0MsR0FBRztJQUN2QyxJQUFJLENBQUNGLFNBQVMsRUFBRTtNQUNacEMsT0FBTyxDQUFDQyxLQUFLLENBQUMsNkVBQTZFZ0MsS0FBSyxRQUFROUIsUUFBUSxDQUFDZSxJQUFJLGlDQUFpQ2UsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDO01BQ25LO0lBQ0o7O0lBRUE7SUFDQUUsZ0JBQWdCLENBQUNKLE9BQU8sQ0FBQ1EsbUJBQW1CLElBQUk7TUFDNUMsTUFBTUMsVUFBVSxHQUFHRCxtQkFBbUIsQ0FBQ0YsSUFBSSxDQUFDQyxHQUFHO01BQy9DLElBQUksQ0FBQzdDLGlCQUFpQixDQUFDK0MsVUFBVSxFQUFFSixTQUFTLENBQUMsRUFBRTtRQUMzQyxJQUFJO1VBQUEsSUFBQUsscUJBQUE7VUFDQyxNQUFNQyxtQkFBbUIsR0FBR0gsbUJBQW1CLENBQUNJLFVBQVU7VUFDMUQsSUFBSUQsbUJBQW1CLENBQUNMLElBQUksQ0FBQ08sSUFBSSxLQUFLLHFCQUFxQixLQUFBSCxxQkFBQSxHQUFJQyxtQkFBbUIsQ0FBQ0MsVUFBVSxjQUFBRixxQkFBQSxnQkFBQUEscUJBQUEsR0FBOUJBLHFCQUFBLENBQWdDSixJQUFJLGNBQUFJLHFCQUFBLGVBQXBDQSxxQkFBQSxDQUFzQ0csSUFBSSxFQUFFO1lBQ3ZHdkMsQ0FBQyxDQUFDcUMsbUJBQW1CLENBQUMsQ0FBQ0csTUFBTSxDQUFDLENBQUM7VUFDbkMsQ0FBQyxNQUFNO1lBQUEsSUFBQUMsaUJBQUE7WUFDSHpDLENBQUMsQ0FBQ2tDLG1CQUFtQixDQUFDLENBQUNNLE1BQU0sQ0FBQyxDQUFDO1lBQy9CN0MsT0FBTyxDQUFDK0MsSUFBSSxDQUFDLDBEQUEwRDVDLFFBQVEsQ0FBQ2UsSUFBSSxXQUFXc0IsVUFBVSxhQUFWQSxVQUFVLGdCQUFBTSxpQkFBQSxHQUFWTixVQUFVLENBQUU1QyxLQUFLLGNBQUFrRCxpQkFBQSx1QkFBakJBLGlCQUFBLENBQW1CakQsSUFBSSx3QkFBd0JvQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUM7VUFDL0o7UUFDTCxDQUFDLENBQUMsT0FBT2hDLEtBQUssRUFBRTtVQUFBLElBQUErQyxrQkFBQTtVQUNaaEQsT0FBTyxDQUFDQyxLQUFLLENBQUMsdUNBQXVDdUMsVUFBVSxhQUFWQSxVQUFVLGdCQUFBUSxrQkFBQSxHQUFWUixVQUFVLENBQUU1QyxLQUFLLGNBQUFvRCxrQkFBQSx1QkFBakJBLGtCQUFBLENBQW1CbkQsSUFBSSxRQUFRTSxRQUFRLENBQUNlLElBQUksaUJBQWlCZSxLQUFLLEdBQUcsQ0FBQyxHQUFHLEVBQUVoQyxLQUFLLENBQUM7UUFDMUk7TUFDSjtJQUNKLENBQUMsQ0FBQzs7SUFFRjtJQUNBLElBQUk7TUFDQSxNQUFNZ0QsVUFBVSxHQUFHZixPQUFPLENBQUN4QixJQUFJLENBQUNMLENBQUMsQ0FBQ00sY0FBYyxDQUFDLENBQzVDdUMsTUFBTSxDQUFDaEMsSUFBSSxJQUNSQSxJQUFJLENBQUNtQixJQUFJLENBQUN6QixNQUFNLENBQUNnQyxJQUFJLEtBQUssWUFBWSxJQUN0QyxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQ08sUUFBUSxDQUFDakMsSUFBSSxDQUFDbUIsSUFBSSxDQUFDekIsTUFBTSxDQUFDQyxJQUFJLENBQzFELENBQUMsQ0FDQUMsS0FBSyxDQUFDLENBQUM7O01BRVo7TUFDQW1DLFVBQVUsQ0FBQ0csT0FBTyxDQUFDLENBQUMsQ0FBQ3JCLE9BQU8sQ0FBQ3NCLFNBQVMsSUFBSTtRQUN0QyxJQUFJQyxrQkFBa0IsR0FBRyxLQUFLO1FBQzlCLElBQUk7VUFDQTtVQUNBLE1BQU1DLFNBQVMsR0FBR0YsU0FBUyxDQUFDaEIsSUFBSSxDQUFDbUIsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFDL0MsSUFBSUMsa0JBQWtCO1VBRXRCLElBQUlGLFNBQVMsS0FBS0EsU0FBUyxDQUFDWCxJQUFJLEtBQUssb0JBQW9CLElBQUlXLFNBQVMsQ0FBQ1gsSUFBSSxLQUFLLHlCQUF5QixDQUFDLElBQUlXLFNBQVMsQ0FBQ0csSUFBSSxDQUFDZCxJQUFJLEtBQUssZ0JBQWdCLEVBQUU7WUFDbkphLGtCQUFrQixHQUFHRixTQUFTLENBQUNHLElBQUk7VUFDeEMsQ0FBQyxNQUFNO1lBQUEsSUFBQUMsbUJBQUE7WUFDRjNELE9BQU8sQ0FBQytDLElBQUksQ0FBQyxrRUFBQVksbUJBQUEsR0FBaUVOLFNBQVMsQ0FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxjQUFBcUIsbUJBQUEsZ0JBQUFBLG1CQUFBLEdBQWxCQSxtQkFBQSxDQUFvQi9ELEtBQUssY0FBQStELG1CQUFBLHVCQUF6QkEsbUJBQUEsQ0FBMkI5RCxJQUFJLFFBQVFNLFFBQVEsQ0FBQ2UsSUFBSSxpQkFBaUJlLEtBQUssR0FBRyxDQUFDLG9DQUFvQyxDQUFDO1lBQ2pNLE9BQU8sQ0FBQztVQUNiOztVQUVBO1VBQ0EsTUFBTTJCLGNBQWMsR0FBR3ZELENBQUMsQ0FBQ29ELGtCQUFrQixDQUFDLENBQUMvQyxJQUFJLENBQUNMLENBQUMsQ0FBQ00sY0FBYyxFQUFFO1lBQ2hFQyxNQUFNLEVBQUU7Y0FBRUMsSUFBSSxFQUFFO1lBQUs7VUFDekIsQ0FBQyxDQUFDO1VBRUYsSUFBSStDLGNBQWMsQ0FBQzdDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0I7WUFDQXVDLGtCQUFrQixHQUFHLElBQUk7VUFDN0I7UUFFSixDQUFDLENBQUMsT0FBT08sU0FBUyxFQUFDO1VBQUEsSUFBQUMsb0JBQUE7VUFDZDlELE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLDJEQUFBNkQsb0JBQUEsR0FBMERULFNBQVMsQ0FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxjQUFBd0Isb0JBQUEsZ0JBQUFBLG9CQUFBLEdBQWxCQSxvQkFBQSxDQUFvQmxFLEtBQUssY0FBQWtFLG9CQUFBLHVCQUF6QkEsb0JBQUEsQ0FBMkJqRSxJQUFJLFFBQVFNLFFBQVEsQ0FBQ2UsSUFBSSxpQkFBaUJlLEtBQUssR0FBRyxDQUFDLEdBQUcsRUFBRTRCLFNBQVMsQ0FBQztVQUNyS1Asa0JBQWtCLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDakM7UUFFQSxJQUFJQSxrQkFBa0IsRUFBRTtVQUNuQixNQUFNWixtQkFBbUIsR0FBR1csU0FBUyxDQUFDVixVQUFVO1VBQ2hELElBQUlELG1CQUFtQixDQUFDTCxJQUFJLENBQUNPLElBQUksS0FBSyxxQkFBcUIsRUFBRTtZQUFBLElBQUFtQixvQkFBQTtZQUN6RDFELENBQUMsQ0FBQ3FDLG1CQUFtQixDQUFDLENBQUNHLE1BQU0sQ0FBQyxDQUFDO1lBQy9CN0MsT0FBTyxDQUFDaUIsR0FBRyxDQUFDLGlDQUFBOEMsb0JBQUEsR0FBZ0NWLFNBQVMsQ0FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxjQUFBeUIsb0JBQUEsZ0JBQUFBLG9CQUFBLEdBQWxCQSxvQkFBQSxDQUFvQm5FLEtBQUssY0FBQW1FLG9CQUFBLHVCQUF6QkEsb0JBQUEsQ0FBMkJsRSxJQUFJLDBCQUEwQm9DLEtBQUssR0FBRyxDQUFDLGdDQUFnQyxDQUFDO1VBQ25KLENBQUMsTUFBTTtZQUFBLElBQUErQixvQkFBQTtZQUNIaEUsT0FBTyxDQUFDK0MsSUFBSSxDQUFDLHlDQUFBaUIsb0JBQUEsR0FBd0NYLFNBQVMsQ0FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxjQUFBMEIsb0JBQUEsZ0JBQUFBLG9CQUFBLEdBQWxCQSxvQkFBQSxDQUFvQnBFLEtBQUssY0FBQW9FLG9CQUFBLHVCQUF6QkEsb0JBQUEsQ0FBMkJuRSxJQUFJLDJGQUEyRm9DLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQztVQUNoTTtRQUNMO01BQ0osQ0FBQyxDQUFDO0lBQ04sQ0FBQyxDQUFDLE9BQU9oQyxLQUFLLEVBQUU7TUFDWkQsT0FBTyxDQUFDQyxLQUFLLENBQUMsNERBQTRERSxRQUFRLENBQUNlLElBQUksaUJBQWlCZSxLQUFLLEdBQUcsQ0FBQyxHQUFHLEVBQUVoQyxLQUFLLENBQUM7SUFDaEk7SUFDQTs7SUFFQTtJQUNBLElBQUk7TUFDQSxNQUFNZ0UsZ0JBQWdCLEdBQUcvQixPQUFPLENBQUN4QixJQUFJLENBQUNMLENBQUMsQ0FBQ00sY0FBYyxFQUFFO1FBQ3BEQyxNQUFNLEVBQUU7VUFBRUMsSUFBSSxFQUFFO1FBQVU7TUFDOUIsQ0FBQyxDQUFDLENBQUNDLEtBQUssQ0FBQyxDQUFDO01BRVZtRCxnQkFBZ0IsQ0FBQ2IsT0FBTyxDQUFDLENBQUMsQ0FBQ3JCLE9BQU8sQ0FBQ21DLGVBQWUsSUFBSTtRQUNsRCxNQUFNQyxXQUFXLEdBQUdELGVBQWUsQ0FBQzdCLElBQUk7UUFDeEMsSUFBSSxDQUFDOEIsV0FBVyxDQUFDWCxTQUFTLElBQUlXLFdBQVcsQ0FBQ1gsU0FBUyxDQUFDekMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUVoRSxNQUFNcUQsZUFBZSxHQUFHRCxXQUFXLENBQUNYLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDWSxlQUFlLElBQUksQ0FBQ0EsZUFBZSxDQUFDVixJQUFJLElBQUlVLGVBQWUsQ0FBQ1YsSUFBSSxDQUFDZCxJQUFJLEtBQUssZ0JBQWdCLEVBQUU7UUFFakcsTUFBTXlCLGVBQWUsR0FBR0QsZUFBZSxDQUFDVixJQUFJO1FBQzVDO1FBQ0EsSUFBSSxDQUFDVyxlQUFlLENBQUNYLElBQUksSUFBSVcsZUFBZSxDQUFDWCxJQUFJLENBQUMzQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1VBQzVEO1FBQ0o7UUFFQSxNQUFNdUQsNEJBQTRCLEdBQUdELGVBQWUsQ0FBQ1gsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUM1RDtRQUNBLElBQUlZLDRCQUE0QixDQUFDMUIsSUFBSSxLQUFLLHFCQUFxQixJQUMzRDBCLDRCQUE0QixDQUFDQyxVQUFVLElBQ3ZDRCw0QkFBNEIsQ0FBQ0MsVUFBVSxDQUFDM0IsSUFBSSxLQUFLLGdCQUFnQixJQUNqRTBCLDRCQUE0QixDQUFDQyxVQUFVLENBQUMzRCxNQUFNLElBQzlDMEQsNEJBQTRCLENBQUNDLFVBQVUsQ0FBQzNELE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLElBQUksRUFBRTtVQUU5RDtVQUNBO1VBQ0EsTUFBTTJELG9CQUFvQixHQUFHTixlQUFlLENBQUN2QixVQUFVO1VBQ3ZELElBQUk2QixvQkFBb0IsQ0FBQ25DLElBQUksQ0FBQ08sSUFBSSxLQUFLLHFCQUFxQixFQUFFO1lBQUEsSUFBQTZCLGdCQUFBO1lBQzFEO1lBQ0FwRSxDQUFDLENBQUNtRSxvQkFBb0IsQ0FBQyxDQUFDRSxXQUFXLENBQUNKLDRCQUE0QixDQUFDO1lBQ2pFdEUsT0FBTyxDQUFDaUIsR0FBRyxDQUFDLHFDQUFBd0QsZ0JBQUEsR0FBb0NOLFdBQVcsQ0FBQzdCLEdBQUcsY0FBQW1DLGdCQUFBLGdCQUFBQSxnQkFBQSxHQUFmQSxnQkFBQSxDQUFpQjdFLEtBQUssY0FBQTZFLGdCQUFBLHVCQUF0QkEsZ0JBQUEsQ0FBd0I1RSxJQUFJLGdCQUFnQm9DLEtBQUssR0FBRyxDQUFDLHVDQUF1QyxDQUFDO1VBQ2pKLENBQUMsTUFBTTtZQUFBLElBQUEwQyxpQkFBQTtZQUNIM0UsT0FBTyxDQUFDK0MsSUFBSSxDQUFDLGlDQUFBNEIsaUJBQUEsR0FBZ0NSLFdBQVcsQ0FBQzdCLEdBQUcsY0FBQXFDLGlCQUFBLGdCQUFBQSxpQkFBQSxHQUFmQSxpQkFBQSxDQUFpQi9FLEtBQUssY0FBQStFLGlCQUFBLHVCQUF0QkEsaUJBQUEsQ0FBd0I5RSxJQUFJLHlHQUF5R29DLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQztVQUNuTTtRQUNKO01BQ0osQ0FBQyxDQUFDO0lBQ04sQ0FBQyxDQUFDLE9BQU9oQyxLQUFLLEVBQUU7TUFDWkQsT0FBTyxDQUFDQyxLQUFLLENBQUMsNkRBQTZERSxRQUFRLENBQUNlLElBQUksaUJBQWlCZSxLQUFLLEdBQUcsQ0FBQyxHQUFHLEVBQUVoQyxLQUFLLENBQUM7SUFDakk7SUFDQTs7SUFFQTtJQUNBLE1BQU0yRSxZQUFZLEdBQUcxQyxPQUFPLENBQUMyQyxRQUFRLENBQUM7TUFBRUMsS0FBSyxFQUFFLFFBQVE7TUFBRUMsYUFBYSxFQUFFO0lBQUssQ0FBQyxDQUFDOztJQUUvRTtJQUNBLElBQUlDLFdBQVc7SUFDZixJQUFJeEQsUUFBUSxDQUFDeUQsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO01BQzlCLE1BQU1DLGVBQWUsR0FBRzFELFFBQVEsQ0FBQzJELFNBQVMsQ0FBQyxDQUFDLEVBQUUzRCxRQUFRLENBQUNULE1BQU0sR0FBRyxPQUFPLENBQUNBLE1BQU0sQ0FBQztNQUMvRWlFLFdBQVcsR0FBRyxHQUFHRSxlQUFlLEdBQUdqRCxLQUFLLEdBQUcsQ0FBQyxRQUFRWCxHQUFHLEVBQUU7SUFDM0QsQ0FBQyxNQUFNO01BQ0w7TUFDQTtNQUNBO01BQ0EwRCxXQUFXLEdBQUcsR0FBR3hELFFBQVEsR0FBR1MsS0FBSyxHQUFHLENBQUMsR0FBR1gsR0FBRyxFQUFFO01BQzdDdEIsT0FBTyxDQUFDK0MsSUFBSSxDQUFDLG9DQUFvQ3ZCLFFBQVEsR0FBR0YsR0FBRywwREFBMEQwRCxXQUFXLEVBQUUsQ0FBQztJQUN6STtJQUNBLE1BQU1JLFdBQVcsR0FBR2xFLGFBQUksQ0FBQ1ksSUFBSSxDQUFDRCxVQUFVLEVBQUVtRCxXQUFXLENBQUMsQ0FBQyxDQUFDOztJQUV4RDtJQUNBLElBQUk7TUFDQSxJQUFJLENBQUNLLFdBQUUsQ0FBQ0MsVUFBVSxDQUFDekQsVUFBVSxDQUFDLEVBQUU7UUFDNUJ3RCxXQUFFLENBQUNFLFNBQVMsQ0FBQzFELFVBQVUsRUFBRTtVQUFFMkQsU0FBUyxFQUFFO1FBQUssQ0FBQyxDQUFDO1FBQzdDLElBQUk5RCxrQkFBa0IsRUFBRTtVQUNwQjFCLE9BQU8sQ0FBQ2lCLEdBQUcsQ0FBQyxvREFBb0RZLFVBQVUsRUFBRSxDQUFDO1FBQ2pGLENBQUMsTUFBTTtVQUNIN0IsT0FBTyxDQUFDaUIsR0FBRyxDQUFDLHNDQUFzQ1ksVUFBVSxFQUFFLENBQUM7UUFDbkU7TUFDSjtJQUNKLENBQUMsQ0FBQyxPQUFPNUIsS0FBSyxFQUFFO01BQ1pELE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLDRCQUE0QjRCLFVBQVUsR0FBRyxFQUFFNUIsS0FBSyxDQUFDO01BQy9ELE9BQU8sQ0FBQztJQUNaOztJQUVBO0lBQ0EsSUFBSTtNQUNGb0YsV0FBRSxDQUFDSSxhQUFhLENBQUNMLFdBQVcsRUFBRVIsWUFBWSxDQUFDO01BQzNDNUUsT0FBTyxDQUFDaUIsR0FBRyxDQUFDLGNBQWNtRSxXQUFXLEVBQUUsQ0FBQztJQUMxQyxDQUFDLENBQUMsT0FBT25GLEtBQUssRUFBRTtNQUNkRCxPQUFPLENBQUNDLEtBQUssQ0FBQyw2QkFBNkJtRixXQUFXLEdBQUcsRUFBRW5GLEtBQUssQ0FBQztJQUNuRTtFQUNGLENBQUMsQ0FBQzs7RUFFRjtFQUNBLE9BQU9lLFNBQVM7QUFDbEI7QUFFTyxNQUFNMEUsTUFBTSxHQUFBQyxPQUFBLENBQUFELE1BQUEsR0FBRyxLQUFLIiwiaWdub3JlTGlzdCI6W119","map":{"version":3,"names":["_fs","_interopRequireDefault","require","_path","e","__esModule","default","locationsAreEqual","locA","locB","start","line","column","end","console","error","transformer","fileInfo","api","j","jscodeshift","root","source","itPaths","find","CallExpression","callee","name","paths","length","undefined","log","path","originalPath","dir","dirname","ext","extname","baseName","basename","customOutputFolder","global","CUSTOM_OUTPUT_FOLDER","resultsDir","join","forEach","targetItPath","index","astCopy","allItPathsInCopy","targetLoc","node","loc","currentItPathInCopy","currentLoc","_parentStatementPath$","parentStatementPath","parentPath","type","remove","_currentLoc$start","warn","_currentLoc$start2","suitePaths","filter","includes","reverse","suitePath","isEffectivelyEmpty","suiteFunc","arguments","blockStatementNode","body","_suitePath$node$loc","itCallsInBlock","findError","_suitePath$node$loc2","_suitePath$node$loc3","_suitePath$node$loc4","contextCallPaths","contextCallPath","contextNode","contextCallback","contextBodyNode","singleStatementInContextBody","expression","contextStatementPath","_contextNode$loc","replaceWith","_contextNode$loc2","outputSource","toSource","quote","trailingComma","newFileName","endsWith","nameWithoutSpec","substring","newFilePath","fs","existsSync","mkdirSync","recursive","writeFileSync","parser","exports"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\Proiektua\\splitITJCodeShift\\","sources":["split-specs-configurable.js"],"sourcesContent":["// split-specs-configurable.js - Modified transformer that accepts custom output folder\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\n// --- Helper Function ---\r\nconst locationsAreEqual = (locA, locB) => {\r\n    if (!locA || !locB) return false;\r\n    try {\r\n        return (\r\n            locA.start.line === locB.start.line &&\r\n            locA.start.column === locB.start.column &&\r\n            locA.end.line === locB.end.line &&\r\n            locA.end.column === locB.end.column\r\n        );\r\n    } catch(e) {\r\n        console.error(\"Error comparando localizaciones:\", e);\r\n        return false;\r\n    }\r\n};\r\n// --- Fin Helper ---\r\n\r\nexport default function transformer(fileInfo, api) {\r\n  const j = api.jscodeshift;\r\n  const root = j(fileInfo.source);\r\n\r\n  const itPaths = root.find(j.CallExpression, {\r\n    callee: { name: 'it' },\r\n  }).paths();\r\n\r\n  if (itPaths.length <= 1) {\r\n    return undefined;\r\n  }\r\n\r\n  console.log(`-> Archivo ${fileInfo.path}: ${itPaths.length} bloque(s) 'it' encontrados. Generando archivos individuales...`);\r\n\r\n  const originalPath = fileInfo.path;\r\n  const dir = path.dirname(originalPath);\r\n  const ext = path.extname(originalPath);\r\n  const baseName = path.basename(originalPath, ext);\r\n\r\n  // Use custom output folder if provided, otherwise default to 'results' subdirectory\r\n  const customOutputFolder = global.CUSTOM_OUTPUT_FOLDER;\r\n  const resultsDir = customOutputFolder || path.join(dir, 'results');\r\n\r\n  itPaths.forEach((targetItPath, index) => {\r\n    // 1. Crear copia fresca del AST\r\n    const astCopy = j(fileInfo.source);\r\n\r\n    // 2. Encontrar todos los 'it' en la copia\r\n    const allItPathsInCopy = astCopy.find(j.CallExpression, {\r\n        callee: { name: 'it' },\r\n      }).paths();\r\n\r\n    // 3. Obtener la ubicación del 'it' a conservar\r\n    const targetLoc = targetItPath.node.loc;\r\n    if (!targetLoc) {\r\n        console.error(`Error Crítico: Falta información de ubicación para el bloque 'it' (índice ${index}) en ${fileInfo.path}. No se puede generar archivo ${index + 1}.`);\r\n        return;\r\n    }\r\n\r\n    // 4. Eliminar los 'it' cuya ubicación NO COINCIDA\r\n    allItPathsInCopy.forEach(currentItPathInCopy => {\r\n        const currentLoc = currentItPathInCopy.node.loc;\r\n        if (!locationsAreEqual(currentLoc, targetLoc)) {\r\n            try {\r\n                 const parentStatementPath = currentItPathInCopy.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement' && parentStatementPath.parentPath?.node?.type) {\r\n                     j(parentStatementPath).remove();\r\n                 } else {\r\n                     j(currentItPathInCopy).remove();\r\n                     console.warn(`Advertencia: Estructura inesperada para bloque 'it' en ${fileInfo.path} (línea ${currentLoc?.start?.line}). Revise el archivo ${index + 1}.`);\r\n                 }\r\n            } catch (error) {\r\n                console.error(`Error eliminando bloque 'it' (línea ${currentLoc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n            }\r\n        }\r\n    });\r\n\r\n    // 5. --- NUEVO PASO: Eliminar bloques 'describe' o 'context' vacíos ---\r\n    try {\r\n        const suitePaths = astCopy.find(j.CallExpression)\r\n            .filter(path =>\r\n                path.node.callee.type === 'Identifier' &&\r\n                ['describe', 'context'].includes(path.node.callee.name)\r\n            )\r\n            .paths();\r\n\r\n        // Iterar en REVERSA es importante al eliminar nodos para no afectar índices/paths\r\n        suitePaths.reverse().forEach(suitePath => {\r\n            let isEffectivelyEmpty = false;\r\n            try {\r\n                // Acceder al cuerpo (BlockStatement) de la función del describe/context\r\n                const suiteFunc = suitePath.node.arguments[1]; // El callback es usualmente el 2º argumento\r\n                let blockStatementNode;\r\n\r\n                if (suiteFunc && (suiteFunc.type === 'FunctionExpression' || suiteFunc.type === 'ArrowFunctionExpression') && suiteFunc.body.type === 'BlockStatement') {\r\n                     blockStatementNode = suiteFunc.body;\r\n                } else {\r\n                     console.warn(`Advertencia: Estructura inesperada en describe/context (línea ${suitePath.node.loc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}. No se considerará para limpieza.`);\r\n                     return; // Saltar al siguiente suitePath\r\n                }\r\n\r\n                // Comprobar si el cuerpo contiene llamadas 'it'\r\n                const itCallsInBlock = j(blockStatementNode).find(j.CallExpression, {\r\n                    callee: { name: 'it' }\r\n                });\r\n\r\n                if (itCallsInBlock.length === 0) {\r\n                    // No hay llamadas 'it' en este bloque describe/context.\r\n                    isEffectivelyEmpty = true;\r\n                }\r\n\r\n            } catch (findError){\r\n                 console.error(`Error inspeccionando cuerpo de describe/context (línea ${suitePath.node.loc?.start?.line}) en ${fileInfo.path} para archivo ${index + 1}:`, findError);\r\n                 isEffectivelyEmpty = false; // No eliminar si hubo error al inspeccionar\r\n            }\r\n\r\n            if (isEffectivelyEmpty) {\r\n                 const parentStatementPath = suitePath.parentPath;\r\n                 if (parentStatementPath.node.type === 'ExpressionStatement') {\r\n                     j(parentStatementPath).remove();\r\n                     console.log(`   - Describe/Context (línea ${suitePath.node.loc?.start?.line}) eliminado en archivo ${index + 1} por no contener bloques 'it'.`);\r\n                 } else {\r\n                     console.warn(`Advertencia: Describe/Context (línea ${suitePath.node.loc?.start?.line}) sin bloques 'it' no estaba en un ExpressionStatement directo y no se eliminó. Archivo ${index + 1}.`);\r\n                 }\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error(`Error durante la limpieza de bloques describe/context en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n    }\r\n    // --- FIN NUEVO PASO ---\r\n\r\n    // 5.1 --- NUEVO PASO: Desenvolver 'context' si solo contiene el bloque 'it' objetivo ---\r\n    try {\r\n        const contextCallPaths = astCopy.find(j.CallExpression, {\r\n            callee: { name: 'context' }\r\n        }).paths();\r\n\r\n        contextCallPaths.reverse().forEach(contextCallPath => {\r\n            const contextNode = contextCallPath.node;\r\n            if (!contextNode.arguments || contextNode.arguments.length < 2) return;\r\n\r\n            const contextCallback = contextNode.arguments[1];\r\n            if (!contextCallback || !contextCallback.body || contextCallback.body.type !== 'BlockStatement') return;\r\n\r\n            const contextBodyNode = contextCallback.body;\r\n            // Verificar que el cuerpo del context contenga exactamente una declaración\r\n            if (!contextBodyNode.body || contextBodyNode.body.length !== 1) {\r\n                return;\r\n            }\r\n\r\n            const singleStatementInContextBody = contextBodyNode.body[0];\r\n            // Verificar que la única declaración sea una ExpressionStatement que llama a 'it'\r\n            if (singleStatementInContextBody.type === 'ExpressionStatement' &&\r\n                singleStatementInContextBody.expression &&\r\n                singleStatementInContextBody.expression.type === 'CallExpression' &&\r\n                singleStatementInContextBody.expression.callee &&\r\n                singleStatementInContextBody.expression.callee.name === 'it') {\r\n\r\n                // Este 'context' contiene únicamente una llamada 'it'.\r\n                // Dado que otros 'it' fueron eliminados en el paso 4, este 'it' es el objetivo.\r\n                const contextStatementPath = contextCallPath.parentPath;\r\n                if (contextStatementPath.node.type === 'ExpressionStatement') {\r\n                    // Reemplazar el ExpressionStatement del 'context' con el ExpressionStatement del 'it'\r\n                    j(contextStatementPath).replaceWith(singleStatementInContextBody);\r\n                    console.log(`   - Contexto desenvuelto (línea ${contextNode.loc?.start?.line}) en archivo ${index + 1} porque solo contenía un bloque 'it'.`);\r\n                } else {\r\n                    console.warn(`Advertencia: Contexto (línea ${contextNode.loc?.start?.line}) que solo contenía un 'it' no estaba en un ExpressionStatement directo. No se desenvolvió en archivo ${index + 1}.`);\r\n                }\r\n            }\r\n        });\r\n    } catch (error) {\r\n        console.error(`Error durante el desenvolvimiento de bloques 'context' en ${fileInfo.path} para archivo ${index + 1}:`, error);\r\n    }\r\n    // --- FIN NUEVO PASO 5.1 ---\r\n\r\n    // 6. Generar código fuente desde el AST modificado (ahora también sin describes vacíos)\r\n    const outputSource = astCopy.toSource({ quote: 'single', trailingComma: true });\r\n\r\n    // 7. Construir nuevo nombre de archivo y ruta de directorio de resultados\r\n    let newFileName;\r\n    if (baseName.endsWith('.spec')) {\r\n      const nameWithoutSpec = baseName.substring(0, baseName.length - '.spec'.length);\r\n      newFileName = `${nameWithoutSpec}${index + 1}.spec${ext}`;\r\n    } else {\r\n      // Fallback for other naming conventions if needed, or stick to original logic\r\n      // For now, let's assume files are *.spec.ext or handle as an error/warning\r\n      // Sticking to a modified version of original logic for non .spec files for broader compatibility\r\n      newFileName = `${baseName}${index + 1}${ext}`;\r\n      console.warn(`   Advertencia: El archivo base \"${baseName}${ext}\" no termina con '.spec'. Se usó el formato de nombre: ${newFileName}`);\r\n    }\r\n    const newFilePath = path.join(resultsDir, newFileName); // Ruta completa usando resultsDir configurable\r\n\r\n    // 8. Asegurarse de que el directorio de salida exista\r\n    try {\r\n        if (!fs.existsSync(resultsDir)) {\r\n            fs.mkdirSync(resultsDir, { recursive: true });\r\n            if (customOutputFolder) {\r\n                console.log(`   Directorio de salida personalizado creado en: ${resultsDir}`);\r\n            } else {\r\n                console.log(`   Directorio 'results' creado en: ${resultsDir}`);\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error(`Error creando directorio ${resultsDir}:`, error);\r\n        return; // No continuar si no se puede crear el directorio\r\n    }\r\n\r\n    // 9. Escribir el nuevo archivo en el directorio de salida\r\n    try {\r\n      fs.writeFileSync(newFilePath, outputSource);\r\n      console.log(`   Creado: ${newFilePath}`);\r\n    } catch (error) {\r\n      console.error(`Error escribiendo archivo ${newFilePath}:`, error);\r\n    }\r\n  });\r\n\r\n  // Devolver undefined/null para no modificar el original\r\n  return undefined;\r\n}\r\n\r\nexport const parser = 'tsx';\r\n"],"mappings":"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","ignoreList":[]}},"mtime":1749060428279},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\\\\node_modules\\\\jscodeshift\\\\parser\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\\\\node_modules\\\\jscodeshift\\\\parser\\\\tsx.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst babylon = require('@babel/parser');\nconst baseOptions = require('./tsOptions');\nconst options = Object.assign({}, baseOptions);\noptions.plugins = ['jsx'].concat(baseOptions.plugins);\n\n/**\n * Doesn't accept custom options because babylon should be used directly in\n * that case.\n */\nmodule.exports = function () {\n  return {\n    parse(code) {\n      return babylon.parse(code, options);\n    }\n  };\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJiYWJ5bG9uIiwicmVxdWlyZSIsImJhc2VPcHRpb25zIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsInBsdWdpbnMiLCJjb25jYXQiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2UiLCJjb2RlIl0sInNvdXJjZVJvb3QiOiJDOlxcVXNlcnNcXHhhYmlhXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcNC5NYWlsYVxcVEZHLUJlc3RlbGFrb2FrXFxCZXN0ZWxha29ha1xcUHJvaWVrdHVhXFxzcGxpdElUSkNvZGVTaGlmdFxcbm9kZV9tb2R1bGVzXFxqc2NvZGVzaGlmdFxccGFyc2VyXFwiLCJzb3VyY2VzIjpbInRzeC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBiYWJ5bG9uID0gcmVxdWlyZSgnQGJhYmVsL3BhcnNlcicpO1xuY29uc3QgYmFzZU9wdGlvbnMgPSByZXF1aXJlKCcuL3RzT3B0aW9ucycpO1xuXG5jb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZU9wdGlvbnMpO1xub3B0aW9ucy5wbHVnaW5zID0gWydqc3gnXS5jb25jYXQoYmFzZU9wdGlvbnMucGx1Z2lucyk7XG5cbi8qKlxuICogRG9lc24ndCBhY2NlcHQgY3VzdG9tIG9wdGlvbnMgYmVjYXVzZSBiYWJ5bG9uIHNob3VsZCBiZSB1c2VkIGRpcmVjdGx5IGluXG4gKiB0aGF0IGNhc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcGFyc2UoY29kZSkge1xuICAgICAgcmV0dXJuIGJhYnlsb24ucGFyc2UoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaLE1BQU1BLE9BQU8sR0FBR0MsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUN4QyxNQUFNQyxXQUFXLEdBQUdELE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFFMUMsTUFBTUUsT0FBTyxHQUFHQyxNQUFNLENBQUNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRUgsV0FBVyxDQUFDO0FBQzlDQyxPQUFPLENBQUNHLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDQyxNQUFNLENBQUNMLFdBQVcsQ0FBQ0ksT0FBTyxDQUFDOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxNQUFNLENBQUNDLE9BQU8sR0FBRyxZQUFXO0VBQzFCLE9BQU87SUFDTEMsS0FBS0EsQ0FBQ0MsSUFBSSxFQUFFO01BQ1YsT0FBT1gsT0FBTyxDQUFDVSxLQUFLLENBQUNDLElBQUksRUFBRVIsT0FBTyxDQUFDO0lBQ3JDO0VBQ0YsQ0FBQztBQUNILENBQUMiLCJpZ25vcmVMaXN0IjpbXX0=","map":{"version":3,"names":["babylon","require","baseOptions","options","Object","assign","plugins","concat","module","exports","parse","code"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\Proiektua\\splitITJCodeShift\\node_modules\\jscodeshift\\parser\\","sources":["tsx.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst babylon = require('@babel/parser');\nconst baseOptions = require('./tsOptions');\n\nconst options = Object.assign({}, baseOptions);\noptions.plugins = ['jsx'].concat(baseOptions.plugins);\n\n/**\n * Doesn't accept custom options because babylon should be used directly in\n * that case.\n */\nmodule.exports = function() {\n  return {\n    parse(code) {\n      return babylon.parse(code, options);\n    },\n  };\n};\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,eAAe,CAAC;AACxC,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAa,CAAC;AAE1C,MAAME,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEH,WAAW,CAAC;AAC9CC,OAAO,CAACG,OAAO,GAAG,CAAC,KAAK,CAAC,CAACC,MAAM,CAACL,WAAW,CAACI,OAAO,CAAC;;AAErD;AACA;AACA;AACA;AACAE,MAAM,CAACC,OAAO,GAAG,YAAW;EAC1B,OAAO;IACLC,KAAKA,CAACC,IAAI,EAAE;MACV,OAAOX,OAAO,CAACU,KAAK,CAACC,IAAI,EAAER,OAAO,CAAC;IACrC;EACF,CAAC;AACH,CAAC","ignoreList":[]}},"mtime":1746461488467},"{\"assumptions\":{},\"sourceRoot\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\\\\node_modules\\\\jscodeshift\\\\parser\\\\\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\",\"filename\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\\\\node_modules\\\\jscodeshift\\\\parser\\\\tsOptions.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"C:\\\\Users\\\\xabia\\\\OneDrive\\\\Documentos\\\\4.Maila\\\\TFG-Bestelakoak\\\\Bestelakoak\\\\Proiektua\\\\splitITJCodeShift\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Options shared by the TypeScript and TSX parsers.\n */\nmodule.exports = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: ['asyncGenerators', 'decoratorAutoAccessors', 'bigInt', 'classPrivateMethods', 'classPrivateProperties', 'classProperties', 'decorators-legacy', 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportExtensions', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importAttributes', 'importMeta', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', ['pipelineOperator', {\n    proposal: 'minimal'\n  }], 'throwExpressions', 'typescript']\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwic291cmNlVHlwZSIsImFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSIsImFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uIiwic3RhcnRMaW5lIiwidG9rZW5zIiwicGx1Z2lucyIsInByb3Bvc2FsIl0sInNvdXJjZVJvb3QiOiJDOlxcVXNlcnNcXHhhYmlhXFxPbmVEcml2ZVxcRG9jdW1lbnRvc1xcNC5NYWlsYVxcVEZHLUJlc3RlbGFrb2FrXFxCZXN0ZWxha29ha1xcUHJvaWVrdHVhXFxzcGxpdElUSkNvZGVTaGlmdFxcbm9kZV9tb2R1bGVzXFxqc2NvZGVzaGlmdFxccGFyc2VyXFwiLCJzb3VyY2VzIjpbInRzT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE9wdGlvbnMgc2hhcmVkIGJ5IHRoZSBUeXBlU2NyaXB0IGFuZCBUU1ggcGFyc2Vycy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxuICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IHRydWUsXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICBzdGFydExpbmU6IDEsXG4gIHRva2VuczogdHJ1ZSxcbiAgcGx1Z2luczogW1xuICAgICdhc3luY0dlbmVyYXRvcnMnLFxuICAgICdkZWNvcmF0b3JBdXRvQWNjZXNzb3JzJyxcbiAgICAnYmlnSW50JyxcbiAgICAnY2xhc3NQcml2YXRlTWV0aG9kcycsXG4gICAgJ2NsYXNzUHJpdmF0ZVByb3BlcnRpZXMnLFxuICAgICdjbGFzc1Byb3BlcnRpZXMnLFxuICAgICdkZWNvcmF0b3JzLWxlZ2FjeScsXG4gICAgJ2RvRXhwcmVzc2lvbnMnLFxuICAgICdkeW5hbWljSW1wb3J0JyxcbiAgICAnZXhwb3J0RGVmYXVsdEZyb20nLFxuICAgICdleHBvcnRFeHRlbnNpb25zJyxcbiAgICAnZXhwb3J0TmFtZXNwYWNlRnJvbScsXG4gICAgJ2Z1bmN0aW9uQmluZCcsXG4gICAgJ2Z1bmN0aW9uU2VudCcsXG4gICAgJ2ltcG9ydEF0dHJpYnV0ZXMnLFxuICAgICdpbXBvcnRNZXRhJyxcbiAgICAnbnVsbGlzaENvYWxlc2NpbmdPcGVyYXRvcicsXG4gICAgJ251bWVyaWNTZXBhcmF0b3InLFxuICAgICdvYmplY3RSZXN0U3ByZWFkJyxcbiAgICAnb3B0aW9uYWxDYXRjaEJpbmRpbmcnLFxuICAgICdvcHRpb25hbENoYWluaW5nJyxcbiAgICBbJ3BpcGVsaW5lT3BlcmF0b3InLCB7IHByb3Bvc2FsOiAnbWluaW1hbCcgfV0sXG4gICAgJ3Rocm93RXhwcmVzc2lvbnMnLFxuICAgICd0eXBlc2NyaXB0J1xuICBdLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0FBLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2ZDLFVBQVUsRUFBRSxRQUFRO0VBQ3BCQywyQkFBMkIsRUFBRSxJQUFJO0VBQ2pDQywwQkFBMEIsRUFBRSxJQUFJO0VBQ2hDQyxTQUFTLEVBQUUsQ0FBQztFQUNaQyxNQUFNLEVBQUUsSUFBSTtFQUNaQyxPQUFPLEVBQUUsQ0FDUCxpQkFBaUIsRUFDakIsd0JBQXdCLEVBQ3hCLFFBQVEsRUFDUixxQkFBcUIsRUFDckIsd0JBQXdCLEVBQ3hCLGlCQUFpQixFQUNqQixtQkFBbUIsRUFDbkIsZUFBZSxFQUNmLGVBQWUsRUFDZixtQkFBbUIsRUFDbkIsa0JBQWtCLEVBQ2xCLHFCQUFxQixFQUNyQixjQUFjLEVBQ2QsY0FBYyxFQUNkLGtCQUFrQixFQUNsQixZQUFZLEVBQ1osMkJBQTJCLEVBQzNCLGtCQUFrQixFQUNsQixrQkFBa0IsRUFDbEIsc0JBQXNCLEVBQ3RCLGtCQUFrQixFQUNsQixDQUFDLGtCQUFrQixFQUFFO0lBQUVDLFFBQVEsRUFBRTtFQUFVLENBQUMsQ0FBQyxFQUM3QyxrQkFBa0IsRUFDbEIsWUFBWTtBQUVoQixDQUFDIiwiaWdub3JlTGlzdCI6W119","map":{"version":3,"names":["module","exports","sourceType","allowImportExportEverywhere","allowReturnOutsideFunction","startLine","tokens","plugins","proposal"],"sourceRoot":"C:\\Users\\xabia\\OneDrive\\Documentos\\4.Maila\\TFG-Bestelakoak\\Bestelakoak\\Proiektua\\splitITJCodeShift\\node_modules\\jscodeshift\\parser\\","sources":["tsOptions.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Options shared by the TypeScript and TSX parsers.\n */\nmodule.exports = {\n  sourceType: 'module',\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  startLine: 1,\n  tokens: true,\n  plugins: [\n    'asyncGenerators',\n    'decoratorAutoAccessors',\n    'bigInt',\n    'classPrivateMethods',\n    'classPrivateProperties',\n    'classProperties',\n    'decorators-legacy',\n    'doExpressions',\n    'dynamicImport',\n    'exportDefaultFrom',\n    'exportExtensions',\n    'exportNamespaceFrom',\n    'functionBind',\n    'functionSent',\n    'importAttributes',\n    'importMeta',\n    'nullishCoalescingOperator',\n    'numericSeparator',\n    'objectRestSpread',\n    'optionalCatchBinding',\n    'optionalChaining',\n    ['pipelineOperator', { proposal: 'minimal' }],\n    'throwExpressions',\n    'typescript'\n  ],\n};\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAG;EACfC,UAAU,EAAE,QAAQ;EACpBC,2BAA2B,EAAE,IAAI;EACjCC,0BAA0B,EAAE,IAAI;EAChCC,SAAS,EAAE,CAAC;EACZC,MAAM,EAAE,IAAI;EACZC,OAAO,EAAE,CACP,iBAAiB,EACjB,wBAAwB,EACxB,QAAQ,EACR,qBAAqB,EACrB,wBAAwB,EACxB,iBAAiB,EACjB,mBAAmB,EACnB,eAAe,EACf,eAAe,EACf,mBAAmB,EACnB,kBAAkB,EAClB,qBAAqB,EACrB,cAAc,EACd,cAAc,EACd,kBAAkB,EAClB,YAAY,EACZ,2BAA2B,EAC3B,kBAAkB,EAClB,kBAAkB,EAClB,sBAAsB,EACtB,kBAAkB,EAClB,CAAC,kBAAkB,EAAE;IAAEC,QAAQ,EAAE;EAAU,CAAC,CAAC,EAC7C,kBAAkB,EAClB,YAAY;AAEhB,CAAC","ignoreList":[]}},"mtime":1746461488461}}